<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CharsetUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Riak Client for Java</a> &gt; <a href="index.source.html" class="el_package">com.basho.riak.client.core.util</a> &gt; <span class="el_source">CharsetUtils.java</span></div><h1>CharsetUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.basho.riak.client.core.util;

import java.io.UnsupportedEncodingException;
import java.nio.charset.Charset;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Utils for dealing with {@code byte}, {@code String} charset
 * issues
 *
 * This code is mainly from the Trifork fork of the original HTTP client and was written by
 * Krestan Krab and/or Erik Søe Sørensen.
 *
 * @author Russell Brown &lt;russelldb at basho dot com&gt;
 */
<span class="nc" id="L30">public class CharsetUtils</span>
{
<span class="fc" id="L32">    public static Charset ASCII = Charset.forName(&quot;ASCII&quot;);</span>
<span class="fc" id="L33">    public static Charset ISO_8859_1 = Charset.forName(&quot;ISO-8859-1&quot;);</span>
<span class="fc" id="L34">    public static Charset UTF_8 = Charset.forName(&quot;UTF-8&quot;);</span>

    /**
     * RegEx pattern to get the charset from a content-type value.
     */
<span class="fc" id="L39">    private static final Pattern CHARSET_PATT = Pattern.compile(&quot;\\bcharset *= *\&quot;?([^ ;\&quot;]+)\&quot;?&quot;, Pattern.CASE_INSENSITIVE);</span>

    /**
     * Attempts to parse the {@link Charset} from a contentType string.
     *
     * If contentType is null or no charset declaration found, then UTF-8 is
     * returned. If the found Charset declaration is unknown on this platform
     * then a runtime exception is thrown.
     *
     * @param contentType
     * @return a {@link Charset} parsed from a charset declaration in a
     *         {@code contentType} String.
     */
    public static Charset getCharset(String contentType)
    {
<span class="nc bnc" id="L54" title="All 2 branches missed.">        if (contentType == null)</span>
        {
<span class="nc" id="L56">            return UTF_8;</span>
        }

<span class="nc bnc" id="L59" title="All 2 branches missed.">        if (Constants.CTYPE_JSON_UTF8.equals(contentType))</span>
        {
<span class="nc" id="L61">            return UTF_8; // Fast-track</span>
        }

<span class="nc" id="L64">        Matcher matcher = CHARSET_PATT.matcher(contentType);</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">        if (matcher.find())</span>
        {
<span class="nc" id="L67">            String encstr = matcher.group(1);</span>

<span class="nc bnc" id="L69" title="All 2 branches missed.">            if (encstr.equalsIgnoreCase(&quot;UTF-8&quot;))</span>
            {
<span class="nc" id="L71">                return UTF_8; // Fast-track</span>
            }
            else
            {
                try
                {
<span class="nc" id="L77">                    return Charset.forName(encstr.toUpperCase());</span>
                }
<span class="nc" id="L79">                catch (Exception e)</span>
                {
                    // ignore //
                }
            }
        }

<span class="nc" id="L86">        return ISO_8859_1;</span>
    }

    /**
     * Get the actual string value declared as the charset in a content-type
     * string, regardless of its validity.
     * &lt;p&gt;
     * NOTE: this is different from getCharset, which will always return a
     * default value.
     * &lt;/p&gt;
     *
     * @param contentType
     *            the content-type string
     * @return the verbatim charset declared or null if non-exists
     */
    public static String getDeclaredCharset(String contentType)
    {
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">        if (contentType == null)</span>
        {
<span class="nc" id="L105">            return null;</span>
        }

<span class="fc" id="L108">        Matcher matcher = CHARSET_PATT.matcher(contentType);</span>
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">        if (matcher.find())</span>
        {
<span class="fc" id="L111">            String encstr = matcher.group(1);</span>
<span class="fc" id="L112">            return encstr;</span>
        }
        else
        {
<span class="nc" id="L116">            return null;</span>
        }
    }

    /**
     * Adds the utf-8 charset to a content type.
     *
     * @param contentType
     * @return the {@code contentType} with {@literal ;charset=utf-8} appended.
     */
    public static String addUtf8Charset(String contentType)
    {
<span class="nc bnc" id="L128" title="All 2 branches missed.">        if (contentType == null)</span>
        {
<span class="nc" id="L130">            return &quot;text/plain;charset=utf-8&quot;;</span>
        }

<span class="nc" id="L133">        Matcher matcher = CHARSET_PATT.matcher(contentType);</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">        if (matcher.find())</span>
        {
            // replace what ever content-type with utf8
<span class="nc" id="L137">            return contentType.substring(0, matcher.start(1)) + &quot;utf-8&quot; + contentType.substring(matcher.end(1));</span>
        }

<span class="nc" id="L140">        return contentType + &quot;;charset=utf-8&quot;;</span>
    }

    /**
     * Adds the charset to a content type.
     *
     * @param contentType
     * @return the {@code contentType} with {@code charset.name()} appended.
     */
    public static String addCharset(String charset, String contentType)
    {
<span class="nc bnc" id="L151" title="All 2 branches missed.">        if (null == contentType)</span>
        {
<span class="nc" id="L153">            return &quot;text/plain;charset=&quot; + charset;</span>
        }
        else
        {
<span class="nc" id="L157">            Matcher matcher = CHARSET_PATT.matcher(contentType);</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">            if (matcher.find())</span>
            {
                // replace what ever content-type with the charset
<span class="nc" id="L161">                return contentType.substring(0, matcher.start(1)) +</span>
<span class="nc" id="L162">                    charset + contentType.substring(matcher.end(1));</span>
            }
            else
            {
<span class="nc" id="L166">                return contentType + &quot;;charset=&quot; + charset;</span>
            }
        }
    }

    public static String addCharset(Charset charset, String contentType)
    {
<span class="nc" id="L173">        return addCharset(charset.name(), contentType);</span>
    }

    /**
     * Turns a byte[] array into a string in the provided {@link Charset}
     *
     * @param bytes
     * @param charset
     * @return a String
     */
    public static String asString(byte[] bytes, Charset charset)
    {
<span class="nc bnc" id="L185" title="All 2 branches missed.">        if (bytes == null)</span>
        {
<span class="nc" id="L187">            return null;</span>
        }

<span class="nc bnc" id="L190" title="All 2 branches missed.">        if (charset == null)</span>
        {
<span class="nc" id="L192">            throw new IllegalArgumentException(&quot;Cannot get bytes without a Charset&quot;);</span>
        }

        try
        {
<span class="nc" id="L197">            return new String(bytes, charset.name());</span>
        }
<span class="nc" id="L199">        catch (UnsupportedEncodingException e)</span>
        {
<span class="nc" id="L201">            throw new IllegalStateException(charset.name() + &quot; must be present&quot;, e);</span>
        }
    }

    /**
     * Turns a byte[] array into a UTF8 string
     *
     * @param bytes
     * @return a String
     */
    public static String asUTF8String(byte[] bytes)
    {
<span class="nc" id="L213">        return asString(bytes, UTF_8);</span>
    }

    public static String asASCIIString(byte[] bytes)
    {
<span class="nc" id="L218">        return asString(bytes, ASCII);</span>
    }

    /**
     * Turn a string into an array of bytes using the passed {@link Charset}
     *
     * @param string
     * @param charset
     * @return a byte[] array
     */
    public static byte[] asBytes(String string, Charset charset)
    {
<span class="nc bnc" id="L230" title="All 2 branches missed.">        if (string == null)</span>
        {
<span class="nc" id="L232">            return null;</span>
        }

<span class="nc bnc" id="L235" title="All 2 branches missed.">        if (charset == null)</span>
        {
<span class="nc" id="L237">            throw new IllegalArgumentException(&quot;Cannot get bytes without a Charset&quot;);</span>
        }

        try
        {
<span class="nc" id="L242">            return string.getBytes(charset.name());</span>
        }
<span class="nc" id="L244">        catch (UnsupportedEncodingException e)</span>
        {
            //since we are using *actual* charsets, not string lookups, this
            //should *never* happen. But it is better to throw it up than swallow it.
<span class="nc" id="L248">            throw new IllegalStateException(&quot;Charset present&quot;, e);</span>
        }
    }

    /**
     * Turn a UTF-8 encoded string into an array of bytes
     *
     * @param string
     * @return the bytes for the supplied String
     */
    public static byte[] utf8StringToBytes(String string)
    {
<span class="nc" id="L260">        return asBytes(string, UTF_8);</span>
    }

    /**
     * Check if a content-type string has a charset field appended.
     *
     * @param ctype
     *            the content-type string
     * @return true if {@code ctype} has a charset, false otherwise
     */
    public static boolean hasCharset(String ctype)
    {
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">        if (ctype == null)</span>
        {
<span class="nc" id="L274">            return false;</span>
        }
<span class="fc" id="L276">        Matcher matcher = CHARSET_PATT.matcher(ctype);</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">        if (matcher.find())</span>
        {
<span class="fc" id="L279">            return true;</span>
        }
        else
        {
<span class="fc" id="L283">            return false;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>