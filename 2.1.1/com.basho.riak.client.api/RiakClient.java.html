<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RiakClient.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Riak Client for Java</a> &gt; <a href="index.source.html" class="el_package">com.basho.riak.client.api</a> &gt; <span class="el_source">RiakClient.java</span></div><h1>RiakClient.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2013 Basho Technologies Inc
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.basho.riak.client.api;

import com.basho.riak.client.core.RiakCluster;
import com.basho.riak.client.core.RiakFuture;
import com.basho.riak.client.core.RiakNode;
import com.basho.riak.client.core.util.HostAndPort;

import java.net.InetSocketAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * &lt;script src=&quot;https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js&quot;&gt;&lt;/script&gt;
 * The client used to perform operations on Riak.
 * &lt;p&gt;
 * The core of the Java client models a Riak cluster:
 * &lt;/p&gt;
 * &lt;img src=&quot;doc-files/client-image.png&quot;&gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * The easiest way to get started with the client API is using one of the static
 * methods provided to instantiate and start the client:
 * &lt;/p&gt;
 * &lt;pre class=&quot;prettyprint&quot;&gt;
 * {@code
 * RiakClient client =
 *     RiakClient.newClient(&quot;192.168.1.1&quot;,&quot;192.168.1.2&quot;,&quot;192.168.1.3&quot;); } &lt;/pre&gt;
 *
 * Note that the Riak Java client uses the Riak Protocol Buffers API exclusively.
 * &lt;p&gt;
 * For more complex configurations you will instantiate one or more {@link com.basho.riak.client.core.RiakNode}s
 * and build a {@link com.basho.riak.client.core.RiakCluster} to supply to the
 * RiakClient constructor.
 * &lt;/p&gt;
 * &lt;pre class=&quot;prettyprint&quot;&gt;
 * {@code
 * RiakNode.Builder builder = new RiakNode.Builder();
 * builder.withMinConnections(10);
 * builder.withMaxConnections(50);
 *
 * List&lt;String&gt; addresses = new LinkedList&lt;String&gt;();
 * addresses.add(&quot;192.168.1.1&quot;);
 * addresses.add(&quot;192.168.1.2&quot;);
 * addresses.add(&quot;192.168.1.3&quot;);
 *
 * List&lt;RiakNode&gt; nodes = RiakNode.Builder.buildNodes(builder, addresses);
 * RiakCluster cluster = new RiakCluster.Builder(nodes).build();
 * cluster.start();
 * RiakClient client = new RiakClient(cluster); }&lt;/pre&gt;
 * &lt;p&gt;
 * Once you have a client, {@literal RiakCommand}s from the {@literal com.basho.riak.client.api.commands.*}
 * packages are built then executed by the client:
 * &lt;pre class=&quot;prettyprint&quot;&gt;
 * {@code
 * Namespace ns = new Namespace(&quot;default&quot;,&quot;my_bucket&quot;);
 * Location loc = new Location(ns, &quot;my_key&quot;);
 * FetchValue fv = new FetchValue.Builder(loc).build();
 * FetchValue.Response response = client.execute(fv);
 * RiakObject obj = response.getValue(RiakObject.class);}&lt;/pre&gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * You can also execute all {@literal RiakCommand}s asynchronously. A
 * {@link RiakFuture} for the operation is immediately returned:
 * &lt;pre class=&quot;prettyprint&quot;&gt;
 * {@code
 * Namespace ns = new Namespace(&quot;default&quot;,&quot;my_bucket&quot;);
 * Location loc = new Location(ns, &quot;my_key&quot;);
 * FetchValue fv = new FetchValue.Builder(loc).build();
 * RiakFuture&lt;FetchValue.Response, Location&gt; future = client.executeAsync(fv);
 * future.await();
 * if (future.isSuccess())
 * {
 *     FetchValue.Response response = future.getNow();
 *     RiakObject obj = response.getValue(RiakObject.class);
 *     ...
 * }
 * else
 * {
 *     Throwable error = future.cause();
 *     ...
 * }}&lt;/pre&gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * &lt;h1&gt;RiakCommand subclasses&lt;/h1&gt;
 * &lt;h4&gt;Fetching, storing and deleting objects&lt;/h4&gt;
 * &lt;ul&gt;
 * &lt;li&gt;{@link com.basho.riak.client.api.commands.kv.FetchValue}&lt;/li&gt;
 * &lt;li&gt;{@link com.basho.riak.client.api.commands.kv.MultiFetch}&lt;/li&gt;
 * &lt;li&gt;{@link com.basho.riak.client.api.commands.kv.StoreValue}&lt;/li&gt;
 * &lt;li&gt;{@link com.basho.riak.client.api.commands.kv.UpdateValue}&lt;/li&gt;
 * &lt;li&gt;{@link com.basho.riak.client.api.commands.kv.DeleteValue}&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;h4&gt;Listing keys in a namespace&lt;/h4&gt;
 * &lt;ul&gt;&lt;li&gt;{@link com.basho.riak.client.api.commands.kv.ListKeys}&lt;/li&gt;&lt;/ul&gt;
 * &lt;h4&gt;Secondary index (2i) commands&lt;/h4&gt;
 * &lt;ul&gt;
 * &lt;li&gt;{@link com.basho.riak.client.api.commands.indexes.RawIndexQuery}&lt;/li&gt;
 * &lt;li&gt;{@link com.basho.riak.client.api.commands.indexes.BinIndexQuery}&lt;/li&gt;
 * &lt;li&gt;{@link com.basho.riak.client.api.commands.indexes.IntIndexQuery}&lt;/li&gt;
 * &lt;li&gt;{@link com.basho.riak.client.api.commands.indexes.BigIntIndexQuery}&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;h4&gt;Fetching and storing datatypes (CRDTs)&lt;/h4&gt;
 * &lt;ul&gt;
 * &lt;li&gt;{@link com.basho.riak.client.api.commands.datatypes.FetchCounter}&lt;/li&gt;
 * &lt;li&gt;{@link com.basho.riak.client.api.commands.datatypes.FetchSet}&lt;/li&gt;
 * &lt;li&gt;{@link com.basho.riak.client.api.commands.datatypes.FetchMap}&lt;/li&gt;
 * &lt;li&gt;{@link com.basho.riak.client.api.commands.datatypes.UpdateCounter}&lt;/li&gt;
 * &lt;li&gt;{@link com.basho.riak.client.api.commands.datatypes.UpdateSet}&lt;/li&gt;
 * &lt;li&gt;{@link com.basho.riak.client.api.commands.datatypes.UpdateMap}&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;h4&gt;Querying and modifying buckets&lt;/h4&gt;
 * &lt;ul&gt;
 * &lt;li&gt;{@link com.basho.riak.client.api.commands.buckets.FetchBucketProperties}&lt;/li&gt;
 * &lt;li&gt;{@link com.basho.riak.client.api.commands.buckets.StoreBucketProperties}&lt;/li&gt;
 * &lt;li&gt;{@link com.basho.riak.client.api.commands.buckets.ListBuckets}&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;h4&gt;Search commands&lt;/h4&gt;
 * &lt;ul&gt;
 * &lt;li&gt;{@link com.basho.riak.client.api.commands.search.Search}&lt;/li&gt;
 * &lt;li&gt;{@link com.basho.riak.client.api.commands.search.FetchIndex}&lt;/li&gt;
 * &lt;li&gt;{@link com.basho.riak.client.api.commands.search.StoreIndex}&lt;/li&gt;
 * &lt;li&gt;{@link com.basho.riak.client.api.commands.search.DeleteIndex}&lt;/li&gt;
 * &lt;li&gt;{@link com.basho.riak.client.api.commands.search.FetchSchema}&lt;/li&gt;
 * &lt;li&gt;{@link com.basho.riak.client.api.commands.search.StoreSchema}&lt;/li&gt;
* &lt;/ul&gt;
* &lt;h4&gt;Map-Reduce&lt;/h4&gt;
 * &lt;ul&gt;
 * &lt;li&gt;{@link com.basho.riak.client.api.commands.mapreduce.BucketMapReduce}&lt;/li&gt;
 * &lt;li&gt;{@link com.basho.riak.client.api.commands.mapreduce.BucketKeyMapReduce}&lt;/li&gt;
 * &lt;li&gt;{@link com.basho.riak.client.api.commands.mapreduce.IndexMapReduce}&lt;/li&gt;
 * &lt;li&gt;{@link com.basho.riak.client.api.commands.mapreduce.SearchMapReduce}&lt;/li&gt;
 * &lt;/ul&gt;
 * @author Dave Rusek &lt;drusek at basho dot com&gt;
 * @author Brian Roach &lt;roach at basho dot com&gt;
 * @author Alex Moore &lt;amoore at basho.com&gt;
 * @author Sergey Galkin &lt;srggal at gmail dot com&gt;
 * @since 2.0
 */
public class RiakClient
{
    private final RiakCluster cluster;

    /**
     * Create a new RiakClient to perform operations on the given cluster.
     * &lt;p&gt;
     * The RiakClient provides a user API on top of the client core. Once
     * instantiated, commands are submitted to it for execution on Riak.
     * &lt;/p&gt;
     * @param cluster the started RiakCluster to use.
     */
    public RiakClient(RiakCluster cluster)
<span class="fc" id="L175">    {</span>
<span class="fc" id="L176">        this.cluster = cluster;</span>
<span class="fc" id="L177">    }</span>

    /**
     * Static factory method to create a new client instance.
     * This method produces a client that connects to 127.0.0.1 on the default
     * protocol buffers port (8087).
     *
     * @return a new client instance.
     * @throws UnknownHostException
     */
    public static RiakClient newClient() throws UnknownHostException
    {
<span class="nc" id="L189">        RiakNode.Builder builder = new RiakNode.Builder()</span>
<span class="nc" id="L190">                                        .withMinConnections(10);</span>
<span class="nc" id="L191">        RiakCluster cluster = new RiakCluster.Builder(builder.build()).build();</span>
<span class="nc" id="L192">        cluster.start();</span>
<span class="nc" id="L193">        return new RiakClient(cluster);</span>
    }

    /**
     * Static factory method to create a new client instance.
     * This method produces a client connected to the supplied addresses on
     * the supplied port.
     * @param remoteAddresses a list of IP addresses or hostnames
     * @param port the (protocol buffers) port to connect to on the supplied hosts.
     * @return a new client instance
     * @throws UnknownHostException if a supplied hostname cannot be resolved.
     */
     public static RiakClient newClient(int port, String... remoteAddresses) throws UnknownHostException
     {
<span class="nc" id="L207">         return newClient(port, Arrays.asList(remoteAddresses));</span>
     }

    /**
     * Static factory method to create a new client instance.
     * This method produces a client connected to the supplied addresses on
     * the default (protocol buffers) port (8087).
     * @param remoteAddresses a list of IP addresses or hostnames
     * @return a new client instance
     * @throws UnknownHostException if a supplied hostname cannot be resolved.
     */
    public static RiakClient newClient(List&lt;String&gt; remoteAddresses) throws UnknownHostException
    {
<span class="nc" id="L220">        return newClient(RiakNode.Builder.DEFAULT_REMOTE_PORT, remoteAddresses);</span>
    }

    /**
     * Static factory method to create a new client instance.
     * This method produces a client connected to the supplied addresses on
     * the default (protocol buffers) port (8087).
     * @param remoteAddresses a list of IP addresses or hostnames
     * @return a new client instance
     * @throws UnknownHostException if a supplied hostname cannot be resolved.
     */
    public static RiakClient newClient(String... remoteAddresses) throws UnknownHostException
    {
<span class="nc" id="L233">        return newClient(RiakNode.Builder.DEFAULT_REMOTE_PORT, Arrays.asList(remoteAddresses));</span>
    }

    /**
     * Static factory method to create a new client instance.
     * This method produces a client connected to the supplied addresses on
     * the supplied port.
     * @param remoteAddresses a list of IP addresses or hostnames
     * @param port the (protocol buffers) port to connect to on the supplied hosts.
     * @return a new client instance
     * @throws UnknownHostException if a supplied hostname cannot be resolved.
     */
    public static RiakClient newClient(int port, List&lt;String&gt; remoteAddresses) throws UnknownHostException
    {
<span class="fc" id="L247">        RiakNode.Builder builder = createDefaultNodeBuilder()</span>
<span class="fc" id="L248">                                        .withRemotePort(port);</span>
<span class="fc" id="L249">        return newClient(builder, remoteAddresses);</span>
    }

    /**
     * Static factory method to create a new client instance.
     * This method produces a client connected to the supplied addresses.
     * @param addresses one or more addresses to connect to.
     * @return a new RiakClient instance.
     * @throws java.net.UnknownHostException if a supplied hostname cannot be resolved.
     */
    public static RiakClient newClient(InetSocketAddress... addresses) throws UnknownHostException
    {
<span class="nc" id="L261">        final List&lt;String&gt; remoteAddresses = new ArrayList&lt;&gt;(addresses.length);</span>

<span class="nc bnc" id="L263" title="All 2 branches missed.">        for (InetSocketAddress addy : addresses)</span>
        {
<span class="nc" id="L265">            remoteAddresses.add(</span>
<span class="nc" id="L266">                    String.format(&quot;%s:%s&quot;, addy.getHostName(), addy.getPort())</span>
                );
        }

<span class="nc" id="L270">        return newClient(createDefaultNodeBuilder(), remoteAddresses);</span>
    }

    /**
     * Static factory method to create a new client instance.
     * This method produces a client connected to the supplied addresses and containing the {@link RiakNode}s
     * that will be build by using provided builder.
     * @param addresses one or more addresses to connect to.
     * @return a new RiakClient instance.
     * @throws java.net.UnknownHostException if a supplied hostname cannot be resolved.
     * @since 2.0.3
     * @see com.basho.riak.client.core.RiakCluster.Builder#RiakCluster.Builder(RiakNode.Builder, List)
     */
    // NB: IntelliJ will see the above @see statement as invalid, but it's correct: https://bugs.openjdk.java.net/browse/JDK-8031625
    public static RiakClient newClient(RiakNode.Builder nodeBuilder,  List&lt;String&gt; addresses) throws UnknownHostException
    {
<span class="fc" id="L286">        final RiakCluster cluster = new RiakCluster.Builder(nodeBuilder, addresses).build();</span>
<span class="fc" id="L287">        cluster.start();</span>

<span class="fc" id="L289">        return new RiakClient(cluster);</span>
    }

    /**
     * Static factory method to create a new client instance.
     *
     * @since 2.0.3
     * @see #newClient(RiakNode.Builder, List)
     */
    public static RiakClient newClient(RiakNode.Builder nodeBuilder, String... addresses) throws UnknownHostException
    {
<span class="nc" id="L300">        return newClient(nodeBuilder, Arrays.asList(addresses));</span>
    }

    /**
     * Static factory method to create a new client instance.
     *
     * @since 2.0.6
     */
    public static RiakClient newClient(Collection&lt;HostAndPort&gt; hosts) throws UnknownHostException
    {
<span class="nc" id="L310">        return newClient(hosts, createDefaultNodeBuilder());</span>
    }

    /**
     * Static factory method to create a new client instance.
     *
     * @since 2.0.6
     */
    public static RiakClient newClient(Collection&lt;HostAndPort&gt; hosts, RiakNode.Builder nodeBuilder) throws UnknownHostException
    {
<span class="nc" id="L320">        final RiakCluster cluster = new RiakCluster.Builder(hosts, nodeBuilder).build();</span>
<span class="nc" id="L321">        cluster.start();</span>

<span class="nc" id="L323">        return new RiakClient(cluster);</span>
    }

    /**
     *
     * @since 2.0.3
     */
    public static RiakNode.Builder createDefaultNodeBuilder()
    {
<span class="fc" id="L332">        return new RiakNode.Builder()</span>
<span class="fc" id="L333">                .withMinConnections(10);</span>
    }

    /**
     * Execute a RiakCommand synchronously.
     * &lt;p&gt;
     * Calling this method causes the client to execute the provided RiakCommand synchronously.
     * It will block until the operation completes then either return the response
     * on success or throw an exception on failure.
     * &lt;/p&gt;
     *
     * @param command
     *  The RiakCommand to execute.
     * @param &lt;T&gt;
     *  The RiakCommand's return type.
     * @param &lt;S&gt; The RiakCommand's query info type.
     * @return a response from Riak.
     * @throws ExecutionException if the command fails for any reason.
     * @throws InterruptedException
     */
    public &lt;T,S&gt; T execute(RiakCommand&lt;T,S&gt; command) throws ExecutionException, InterruptedException
    {
<span class="fc" id="L355">        return command.execute(cluster);</span>
    }

    /**
     * Execute a RiakCommand synchronously with a specified client timeout.
     * &lt;p&gt;
     * Calling this method causes the client to execute the provided RiakCommand synchronously.
     * It will block until the operation completes or up to the given timeout.
     * It will either return the response on success or throw an
     * exception on failure.
     * Note: Using this timeout is different that setting a timeout on the command
     * itself using the timeout() method of the command's associated builder.
     * The command timeout is a Riak-side timeout value. This timeout is client-side.
     * &lt;/p&gt;
     *
     * @param command
     *            The RiakCommand to execute.
     * @param timeout the amount of time to wait before returning an exception
     * @param unit the unit of time.
     * @param &lt;T&gt;
     *            The RiakCommand's return type.
     * @param &lt;S&gt;
     *            The RiakCommand's query info type.
     * @return a response from Riak.
     * @throws ExecutionException
     *             if the command fails for any reason.
     * @throws InterruptedException
     * @throws TimeoutException
     *             if the call to execute the command did not finish within the time limit
     */
    public &lt;T, S&gt; T execute(RiakCommand&lt;T, S&gt; command, long timeout, TimeUnit unit) throws ExecutionException,
    InterruptedException, TimeoutException {
<span class="fc" id="L387">        return command.execute(cluster, timeout, unit);</span>
    }

    /**
     * Execute a RiakCommand asynchronously.
     * &lt;p&gt;
     * Calling this method  causes the client to execute the provided RiakCommand
     * asynchronously. It will immediately return a RiakFuture that contains the
     * running operation.
     * @param &lt;T&gt; RiakCommand's return type.
     * @param &lt;S&gt; The RiakCommand's query info type.
     * @param command The RiakCommand to execute.
     * @return a RiakFuture for the operation.
     * @see RiakFuture
     */
    public &lt;T,S&gt; RiakFuture&lt;T,S&gt; executeAsync(RiakCommand&lt;T,S&gt; command)
    {
<span class="fc" id="L404">        return command.executeAsync(cluster);</span>
    }

    /**
     * Execute a StreamableRiakCommand asynchronously, and stream the results back before
     * the command {@link RiakFuture#isDone() is done}.
     * &lt;p&gt;
     *     Calling this method  causes the client to execute the provided
     *     StreamableRiakCommand asynchronously.
     *     It will immediately return a RiakFuture that contains an
     *     &lt;b&gt;immediately&lt;/b&gt; available result (via {@link RiakFuture#get()}) that
     *     data will be streamed to.
     *     The RiakFuture will also keep track of the overall operation's progress
     *     with the {@link RiakFuture#isDone}, etc methods.
     * &lt;/p&gt;
     * &lt;p&gt;
     *     Because the consumer thread will poll for new results, it is advisable to check the
     *     consumer thread's interrupted status via
     *     {@link Thread#isInterrupted() Thread.currentThread().isInterrupted() }, as the result
     *     iterator will not propagate an InterruptedException, but it will set the Thread's
     *     interrupted flag.
     * &lt;/p&gt;
     * @param &lt;I&gt; StreamableRiakCommand's immediate return type, available before the command/operation is complete.
     * @param &lt;S&gt; The RiakCommand's query info type.
     * @param command The RiakCommand to execute.
     * @param timeoutMS The polling timeout in milliseconds for each result chunk.
     *                  If the timeout is reached it will try again, instead of blocking indefinitely.
     *                  If the value is too small (less than the average chunk arrival time), the
     *                  result iterator will essentially busy wait.
     *                  If the timeout is too large (much greater than the average chunk arrival time),
     *                  the result iterator can block the consuming thread from seeing the done()
     *                  status until the timeout is reached.
     * @return a RiakFuture for the operation
     * @since 2.1.0
     * @see RiakFuture
     */
    public &lt;I extends StreamableRiakCommand.StreamableResponse,S&gt; RiakFuture&lt;I,S&gt; executeAsyncStreaming(StreamableRiakCommand&lt;I, S, ?, ?&gt; command, int timeoutMS)
    {
<span class="nc" id="L442">        return command.executeAsyncStreaming(cluster, timeoutMS);</span>
    }

    /**
     * Shut down the client and the underlying RiakCluster.
     * &lt;p&gt;
     * The underlying client core (RiakCluster) uses a number of threads as
     * does Netty. Calling this method will shut down all those threads cleanly.
     * Failure to do so may prevent your application from exiting.
     * &lt;/p&gt;
     * @return a future that will complete when shutdown
     */
    public Future&lt;Boolean&gt; shutdown()
    {
<span class="nc" id="L456">        return cluster.shutdown();</span>
    }

    /**
     * Get the RiakCluster being used by this client.
     * &lt;p&gt;
     * Allows for adding/removing nodes, etc.
     * &lt;/p&gt;
     * @return The RiakCluster instance being used by this client.
     */
    public RiakCluster getRiakCluster()
    {
<span class="nc" id="L468">        return cluster;</span>
    }

    /**
     * Cleans up any Thread-Local variables after shutdown.
     * This operation is useful when you are in a container environment, and you
     * do not want to leave the thread local variables in the threads you do not manage.
     * Call this method when your application is being unloaded from the container, &lt;b&gt;after&lt;/b&gt;
     * all {@link RiakNode}, {@link RiakCluster}, and {@link com.basho.riak.client.api.RiakClient}
     * objects are in the shutdown state.
     */
    public void cleanup()
    {
<span class="nc" id="L481">        cluster.cleanup();</span>
<span class="nc" id="L482">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>