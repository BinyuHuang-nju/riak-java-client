<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FetchOperation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Riak Client for Java</a> &gt; <a href="index.source.html" class="el_package">com.basho.riak.client.core.operations</a> &gt; <span class="el_source">FetchOperation.java</span></div><h1>FetchOperation.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2013 Basho Technologies Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.basho.riak.client.core.operations;

import com.basho.riak.client.api.cap.BasicVClock;
import com.basho.riak.client.core.FutureOperation;
import com.basho.riak.client.core.RiakMessage;
import com.basho.riak.client.core.converters.RiakObjectConverter;
import com.basho.riak.client.core.query.Location;
import com.basho.riak.client.core.query.RiakObject;
import com.basho.riak.protobuf.RiakMessageCodes;
import com.basho.riak.protobuf.RiakKvPB;
import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import java.util.LinkedList;
import java.util.List;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * An operation used to fetch an object from Riak.
 *
 * @author Brian Roach &lt;roach at basho dot com&gt;
 * @since 2.0
 */
public class FetchOperation extends FutureOperation&lt;FetchOperation.Response, RiakKvPB.RpbGetResp, Location&gt;
{
    private final RiakKvPB.RpbGetReq.Builder reqBuilder;
    Location location;

<span class="fc" id="L44">    private final Logger logger = LoggerFactory.getLogger(FetchOperation.class);</span>

    private FetchOperation(Builder builder)
<span class="fc" id="L47">    {</span>
<span class="fc" id="L48">        this.reqBuilder = builder.reqBuilder;</span>
<span class="fc" id="L49">        this.location = builder.location;</span>
<span class="fc" id="L50">    }</span>

    @Override
    protected RiakKvPB.RpbGetResp decode(RiakMessage message)
    {
<span class="fc" id="L55">        Operations.checkPBMessageType(message, RiakMessageCodes.MSG_GetResp);</span>

        try
        {
<span class="fc" id="L59">            byte[] data = message.getData();</span>

<span class="pc bpc" id="L61" title="1 of 2 branches missed.">            if (data.length == 0) // not found</span>
            {
<span class="nc" id="L63">                return null;</span>
            }

<span class="fc" id="L66">            return RiakKvPB.RpbGetResp.parseFrom(data);</span>
        }
<span class="nc" id="L68">        catch (InvalidProtocolBufferException e)</span>
        {
<span class="nc" id="L70">            logger.error(&quot;Invalid message received; {}&quot;, e);</span>
<span class="nc" id="L71">            throw new IllegalArgumentException(&quot;Invalid message received&quot;, e);</span>
        }
    }

    @Override
    protected FetchOperation.Response convert(List&lt;RiakKvPB.RpbGetResp&gt; responses)
    {
        // This is not a streaming op, there will only be one response
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">        if (responses.size() &gt; 1)</span>
        {
<span class="nc" id="L81">            logger.error(&quot;Received {} responses when only one was expected.&quot;, responses.size());</span>
        }

<span class="fc" id="L84">        final RiakKvPB.RpbGetResp response = responses.get(0);</span>
<span class="fc" id="L85">        return convert(response);</span>
    }

    static FetchOperation.Response convert(RiakKvPB.RpbGetResp response)
    {
<span class="fc" id="L90">        FetchOperation.Response.Builder responseBuilder =</span>
                new FetchOperation.Response.Builder();

        // If the response is null ... it means not found. Riak only sends
        // a message code and zero bytes when that's the case. (See: decode() )
        // Because that makes sense!
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">        if (null == response)</span>
        {
<span class="nc" id="L98">            responseBuilder.withNotFound(true);</span>
        }
        else
        {
            // To unify the behavior of having just a tombstone vs. siblings
            // that include a tombstone, we create an empty object and mark
            // it deleted
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">            if (response.getContentCount() == 0)</span>
            {
<span class="nc" id="L107">                RiakObject ro = new RiakObject()</span>
<span class="nc" id="L108">                                    .setDeleted(true)</span>
<span class="nc" id="L109">                                    .setVClock(new BasicVClock(response.getVclock().toByteArray()));</span>

<span class="nc" id="L111">                responseBuilder.addObject(ro);</span>
<span class="nc" id="L112">            }</span>
            else
            {
<span class="fc" id="L115">                responseBuilder.addObjects(RiakObjectConverter.convert(response.getContentList(), response.getVclock()));</span>
            }

<span class="pc bpc" id="L118" title="1 of 2 branches missed.">            responseBuilder.withUnchanged(response.hasUnchanged() ? response.getUnchanged() : false);</span>
        }

<span class="fc" id="L121">        return responseBuilder.build();</span>
    }

    @Override
    protected RiakMessage createChannelMessage()
    {
<span class="fc" id="L127">        RiakKvPB.RpbGetReq req = reqBuilder.build();</span>
<span class="fc" id="L128">        return new RiakMessage(RiakMessageCodes.MSG_GetReq, req.toByteArray());</span>
    }

    @Override
    public Location getQueryInfo()
    {
<span class="nc" id="L134">        return location;</span>
    }

    public static class Builder
    {
<span class="fc" id="L139">        private final RiakKvPB.RpbGetReq.Builder reqBuilder =</span>
<span class="fc" id="L140">            RiakKvPB.RpbGetReq.newBuilder();</span>
        private final Location location;

        /**
         * Construct a FetchOperation that will retrieve an object from Riak stored
         * at the provided Location.
         * @param location the location of the object in Riak to fetch.
         */
        public Builder(Location location)
<span class="fc" id="L149">        {</span>
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">            if (location == null)</span>
            {
<span class="nc" id="L152">                throw new IllegalArgumentException(&quot;Location can not be null.&quot;);</span>
            }

<span class="fc" id="L155">            reqBuilder.setKey(ByteString.copyFrom(location.getKey().unsafeGetValue()));</span>
<span class="fc" id="L156">            reqBuilder.setBucket(ByteString.copyFrom(location.getNamespace().getBucketName().unsafeGetValue()));</span>
<span class="fc" id="L157">            reqBuilder.setType(ByteString.copyFrom(location.getNamespace().getBucketType().unsafeGetValue()));</span>
<span class="fc" id="L158">            this.location = location;</span>
<span class="fc" id="L159">        }</span>

        /**
         * Set the R value for this FetchOperation.
         * If not asSet the bucket default is used.
         * @param r the R value.
         * @return a reference to this object.
         */
        public Builder withR(int r)
        {
<span class="nc" id="L169">            reqBuilder.setR(r);</span>
<span class="nc" id="L170">            return this;</span>
        }

        /**
         * Set the PR value for this query.
         * If not asSet the bucket default is used.
         * @param pr the PR value.
         * @return a reference to this object.
         */
        public Builder withPr(int pr)
        {
<span class="nc" id="L181">            reqBuilder.setPr(pr);</span>
<span class="nc" id="L182">            return this;</span>
        }

        /**
        * Set the not_found_ok value.
        * &lt;p&gt;
        * If true a vnode returning notfound for a key increments the r tally.
        * False is higher consistency, true is higher availability.
        * &lt;/p&gt;
        * &lt;p&gt;
        * If not asSet the bucket default is used.
        * &lt;/p&gt;
        * @param notFoundOk the not_found_ok value.
        * @return a reference to this object.
        */
        public Builder withNotFoundOK(boolean notFoundOk)
        {
<span class="nc" id="L199">            reqBuilder.setNotfoundOk(notFoundOk);</span>
<span class="nc" id="L200">            return this;</span>
        }

        /**
        * Set the basic_quorum value.
        * &lt;p&gt;
        * The parameter controls whether a read request should return early in
        * some fail cases.
        * E.g. If a quorum of nodes has already
        * returned notfound/error, don't wait around for the rest.
        * &lt;/p&gt;
        * @param useBasicQuorum the basic_quorum value.
        * @return a reference to this object.
        */
        public Builder withBasicQuorum(boolean useBasicQuorum)
        {
<span class="nc" id="L216">            reqBuilder.setBasicQuorum(useBasicQuorum);</span>
<span class="nc" id="L217">            return this;</span>
        }

        /**
         * Set whether to return tombstones.
         * @param returnDeletedVClock true to return tombstones, false otherwise.
         * @return a reference to this object.
         */
        public Builder withReturnDeletedVClock(boolean returnDeletedVClock)
        {
<span class="nc" id="L227">            reqBuilder.setDeletedvclock(returnDeletedVClock);</span>
<span class="nc" id="L228">            return this;</span>
        }

        /**
         * Return only the metadata.
         * &lt;p&gt;
         * Causes Riak to only return the metadata for the object. The value
         * will be asSet to null.
         * @param headOnly true to return only metadata.
         * @return a reference to this object.
         */
        public Builder withHeadOnly(boolean headOnly)
        {
<span class="nc" id="L241">            reqBuilder.setHead(headOnly);</span>
<span class="nc" id="L242">            return this;</span>
        }

        /**
         * Do not return the object if the supplied vclock matches.
         * @param vclock the vclock to match on
         * @return a refrence to this object.
         */
        public Builder withIfNotModified(byte[] vclock)
        {
<span class="nc" id="L252">            reqBuilder.setIfModified(ByteString.copyFrom(vclock));</span>
<span class="nc" id="L253">            return this;</span>
        }

        /**
         * Set a timeout for this operation.
         * @param timeout a timeout in milliseconds.
         * @return a reference to this object.
         */
        public Builder withTimeout(int timeout)
        {
<span class="nc" id="L263">            reqBuilder.setTimeout(timeout);</span>
<span class="nc" id="L264">            return this;</span>
        }

        /**
         * Set the n_val for this operation.
         * &lt;p&gt;
         * &lt;b&gt;Do not use this unless you understand the ramifications&lt;/b&gt;
         * &lt;/p&gt;
         * @param nval the n_val value
         * @return a reference to this object.
         */
        public Builder withNVal(int nval)
        {
<span class="nc" id="L277">            reqBuilder.setNVal(nval);</span>
<span class="nc" id="L278">            return this;</span>
        }

        /**
         * Set whether to use sloppy_quorum.
         * &lt;p&gt;
         * &lt;b&gt;Do not use this unless you understand the ramifications&lt;/b&gt;
         * &lt;/p&gt;
         * @param sloppyQuorum true to use sloppy_quorum
         * @return a reference to this object.
         */
        public Builder withSloppyQuorum(boolean sloppyQuorum)
        {
<span class="nc" id="L291">            reqBuilder.setSloppyQuorum(sloppyQuorum);</span>
<span class="nc" id="L292">            return this;</span>
        }

        public FetchOperation build()
        {
<span class="fc" id="L297">            return new FetchOperation(this);</span>
        }
    }

    protected static abstract class KvResponseBase
    {
        private final List&lt;RiakObject&gt; objectList;

        protected KvResponseBase(Init&lt;?&gt; builder)
<span class="fc" id="L306">        {</span>
<span class="fc" id="L307">            this.objectList = builder.objectList;</span>
<span class="fc" id="L308">        }</span>

        public List&lt;RiakObject&gt; getObjectList()
        {
<span class="fc" id="L312">            return objectList;</span>
        }

<span class="fc" id="L315">        protected static abstract class Init&lt;T extends Init&lt;T&gt;&gt;</span>
        {
<span class="fc" id="L317">            private final List&lt;RiakObject&gt; objectList = new LinkedList&lt;&gt;();</span>
            protected abstract T self();
            protected abstract KvResponseBase build();

            T addObject(RiakObject object)
            {
<span class="nc" id="L323">                objectList.add(object);</span>
<span class="nc" id="L324">                return self();</span>
            }

            T addObjects(List&lt;RiakObject&gt; objects)
            {
<span class="fc" id="L329">                objectList.addAll(objects);</span>
<span class="fc" id="L330">                return self();</span>
            }
        }
    }

    public static class Response extends KvResponseBase
    {
        private final boolean notFound;
        private final boolean unchanged;

        private Response(Init&lt;?&gt; builder)
        {
<span class="fc" id="L342">            super(builder);</span>
<span class="fc" id="L343">            this.notFound = builder.notFound;</span>
<span class="fc" id="L344">            this.unchanged = builder.unchanged;</span>
<span class="fc" id="L345">        }</span>

        public boolean isNotFound()
        {
<span class="fc" id="L349">            return notFound;</span>
        }

        public boolean isUnchanged()
        {
<span class="nc" id="L354">            return unchanged;</span>
        }

<span class="fc" id="L357">        protected static abstract class Init&lt;T extends Init&lt;T&gt;&gt; extends KvResponseBase.Init&lt;T&gt;</span>
        {
            private boolean notFound;
            private boolean unchanged;

            T withNotFound(boolean notFound)
            {
<span class="nc" id="L364">                this.notFound = notFound;</span>
<span class="nc" id="L365">                return self();</span>
            }

            T withUnchanged(boolean unchanged)
            {
<span class="fc" id="L370">                this.unchanged = unchanged;</span>
<span class="fc" id="L371">                return self();</span>
            }
        }

<span class="fc" id="L375">        static class Builder extends Init&lt;Builder&gt;</span>
        {
            @Override
            protected Builder self()
            {
<span class="fc" id="L380">                return this;</span>
            }

            @Override
            protected Response build()
            {
<span class="fc" id="L386">                return new Response(this);</span>
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>