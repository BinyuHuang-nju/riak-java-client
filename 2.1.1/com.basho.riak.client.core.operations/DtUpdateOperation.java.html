<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DtUpdateOperation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Riak Client for Java</a> &gt; <a href="index.source.html" class="el_package">com.basho.riak.client.core.operations</a> &gt; <span class="el_source">DtUpdateOperation.java</span></div><h1>DtUpdateOperation.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2013 Basho Technologies Inc
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.basho.riak.client.core.operations;

import com.basho.riak.client.core.query.crdt.ops.*;
import com.basho.riak.client.core.FutureOperation;
import com.basho.riak.client.core.RiakMessage;
import com.basho.riak.client.core.converters.CrdtResponseConverter;
import com.basho.riak.client.core.query.Location;
import com.basho.riak.client.core.query.Namespace;
import com.basho.riak.client.core.query.crdt.types.RiakDatatype;
import com.basho.riak.client.core.util.BinaryValue;
import com.basho.riak.protobuf.RiakMessageCodes;
import com.basho.riak.protobuf.RiakDtPB;
import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;

import java.util.List;

public class DtUpdateOperation extends FutureOperation&lt;DtUpdateOperation.Response, RiakDtPB.DtUpdateResp, Location&gt;
{
    private final Location location;
    private final RiakDtPB.DtUpdateReq.Builder reqBuilder;

    private DtUpdateOperation(Builder builder)
<span class="fc" id="L39">    {</span>
<span class="fc" id="L40">        this.reqBuilder = builder.reqBuilder;</span>
<span class="fc" id="L41">        this.location = builder.location;</span>
<span class="fc" id="L42">    }</span>

    @Override
    protected Response convert(List&lt;RiakDtPB.DtUpdateResp&gt; rawResponse)
    {
<span class="nc bnc" id="L47" title="All 2 branches missed.">        if (rawResponse.size() != 1)</span>
        {
<span class="nc" id="L49">            throw new IllegalStateException(&quot;Expecting exactly one response, instead received &quot; + rawResponse.size());</span>
        }

<span class="nc" id="L52">        RiakDtPB.DtUpdateResp response = rawResponse.iterator().next();</span>
<span class="nc" id="L53">        CrdtResponseConverter converter = new CrdtResponseConverter();</span>
<span class="nc" id="L54">        RiakDatatype element = converter.convert(response);</span>

<span class="nc" id="L56">        Response.Builder responseBuilder =</span>
<span class="nc" id="L57">            new Response.Builder().withCrdtElement(element);</span>

<span class="nc bnc" id="L59" title="All 2 branches missed.">        if (response.hasKey())</span>
        {
<span class="nc" id="L61">            BinaryValue key = BinaryValue.unsafeCreate(response.getKey().toByteArray());</span>
<span class="nc" id="L62">            responseBuilder.withGeneratedKey(key);</span>
        }

<span class="nc bnc" id="L65" title="All 2 branches missed.">        if (response.hasContext())</span>
        {
<span class="nc" id="L67">            BinaryValue context = BinaryValue.unsafeCreate(response.getContext().toByteArray());</span>
<span class="nc" id="L68">            responseBuilder.withContext(context);</span>
        }

<span class="nc" id="L71">        return responseBuilder.build();</span>
    }

    @Override
    protected RiakMessage createChannelMessage()
    {
<span class="nc" id="L77">        return new RiakMessage(RiakMessageCodes.MSG_DtUpdateReq, reqBuilder.build().toByteArray());</span>
    }

    @Override
    protected RiakDtPB.DtUpdateResp decode(RiakMessage rawMessage)
    {
<span class="nc" id="L83">        Operations.checkPBMessageType(rawMessage, RiakMessageCodes.MSG_DtUpdateResp);</span>
        try
        {
<span class="nc" id="L86">            RiakDtPB.DtUpdateResp resp = RiakDtPB.DtUpdateResp.parseFrom(rawMessage.getData());</span>
<span class="nc" id="L87">            return resp;</span>
        }
<span class="nc" id="L89">        catch (InvalidProtocolBufferException ex)</span>
        {
<span class="nc" id="L91">            throw new IllegalArgumentException(&quot;Invalid message received&quot;, ex);</span>
        }
    }

    @Override
    public Location getQueryInfo()
    {
<span class="nc" id="L98">        return location;</span>
    }

    public static class Builder
    {
<span class="fc" id="L103">        private final RiakDtPB.DtUpdateReq.Builder reqBuilder = RiakDtPB.DtUpdateReq.newBuilder();</span>
        private final Location location;
<span class="fc" id="L105">        private boolean removeOpPresent = false;</span>

        /**
         * Construct a builder for a DtUpdateOperation.
         * @param location The location of the object in Riak.
         */
        public Builder(Location location)
<span class="fc" id="L112">        {</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">            if (location == null)</span>
            {
<span class="nc" id="L115">                throw new IllegalArgumentException(&quot;Location cannot be null&quot;);</span>
            }
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">            else if (location.getNamespace().getBucketTypeAsString().equals(Namespace.DEFAULT_BUCKET_TYPE))</span>
            {
<span class="nc" id="L119">                throw new IllegalArgumentException(&quot;Default bucket type does not accept CRDTs&quot;);</span>
            }

<span class="fc" id="L122">            reqBuilder.setBucket(ByteString.copyFrom(location.getNamespace().getBucketName().unsafeGetValue()));</span>
<span class="fc" id="L123">            reqBuilder.setType(ByteString.copyFrom(location.getNamespace().getBucketType().unsafeGetValue()));</span>
<span class="fc" id="L124">            reqBuilder.setKey(ByteString.copyFrom(location.getKey().unsafeGetValue()));</span>

<span class="fc" id="L126">            this.location = location;</span>
<span class="fc" id="L127">        }</span>

        public Builder(Namespace namespace)
<span class="fc" id="L130">        {</span>
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">            if (namespace == null)</span>
            {
<span class="nc" id="L133">                throw new IllegalArgumentException(&quot;Namespace cannot be null&quot;);</span>
            }
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">            else if (namespace.getBucketTypeAsString().equals(Namespace.DEFAULT_BUCKET_TYPE))</span>
            {
<span class="nc" id="L137">                throw new IllegalArgumentException(&quot;Default bucket type does not accept CRDTs&quot;);</span>
            }

            // This is simply for the returned query info
<span class="fc" id="L141">            Location loc = new Location(namespace, &quot;RIAK_GENERATED&quot;);</span>

<span class="fc" id="L143">            reqBuilder.setBucket(ByteString.copyFrom(loc.getNamespace().getBucketName().unsafeGetValue()));</span>
<span class="fc" id="L144">            reqBuilder.setType(ByteString.copyFrom(loc.getNamespace().getBucketType().unsafeGetValue()));</span>

<span class="fc" id="L146">            this.location = loc;</span>
<span class="fc" id="L147">        }</span>

        /**
         * Set the context for this operation.
         *
         * @param ctx a context from a previous fetch operation.
         * @return a reference to this object.
         */
        public Builder withContext(BinaryValue ctx)
        {
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">            if (null == ctx)</span>
            {
<span class="nc" id="L159">                throw new IllegalArgumentException(&quot;Context cannot be null.&quot;);</span>
            }
<span class="fc" id="L161">            reqBuilder.setContext(ByteString.copyFrom(ctx.unsafeGetValue()));</span>
<span class="fc" id="L162">            return this;</span>
        }

        /**
         * Set the W value for this DtUpdateOperation.
         * If not asSet the bucket default is used.
         *
         * @param w the W value.
         * @return a reference to this object.
         */
        public Builder withW(int w)
        {
<span class="fc" id="L174">            reqBuilder.setW(w);</span>
<span class="fc" id="L175">            return this;</span>
        }

        /**
         * Set the DW value for this DtUpdateOperation.
         * If not asSet the bucket default is used.
         *
         * @param dw the DW value.
         * @return a reference to this object.
         */
        public Builder withDw(int dw)
        {
<span class="fc" id="L187">            reqBuilder.setDw(dw);</span>
<span class="fc" id="L188">            return this;</span>
        }

        /**
         * Set the PW value for this DtUpdateOperation.
         * If not asSet the bucket default is used.
         *
         * @param pw the PW value.
         * @return a reference to this object.
         */
        public Builder withPw(int pw)
        {
<span class="fc" id="L200">            reqBuilder.setPw(pw);</span>
<span class="fc" id="L201">            return this;</span>
        }

        /**
         * Return the object after storing (including any siblings).
         *
         * @param returnBody true to return the object.
         * @return a reference to this object.
         */
        public Builder withReturnBody(boolean returnBody)
        {
<span class="fc" id="L212">            reqBuilder.setReturnBody(returnBody);</span>
<span class="fc" id="L213">            return this;</span>
        }

        /**
         * Set a timeout for this operation.
         *
         * @param timeout a timeout in milliseconds.
         * @return a reference to this object.
         */
        public Builder withTimeout(int timeout)
        {
<span class="fc" id="L224">            reqBuilder.setTimeout(timeout);</span>
<span class="fc" id="L225">            return this;</span>
        }

        /**
         * Set the n_val value for this operation.
         * &lt;p&gt;
         * &lt;b&gt;Do not use this unless you understand the ramifications&lt;/b&gt;
         * &lt;/p&gt;
         *
         * @param nval the n_val value
         * @return a reference to this object.
         */
        public Builder withNVal(int nval)
        {
<span class="fc" id="L239">            reqBuilder.setNVal(nval);</span>
<span class="fc" id="L240">            return this;</span>
        }

        /**
         * Set whether to use sloppy_quorum.
         * &lt;p&gt;
         * &lt;b&gt;Do not use this unless you understand the ramifications&lt;/b&gt;
         * &lt;/p&gt;
         *
         * @param sloppyQuorum true to use sloppy_quorum
         * @return a reference to this object.
         */
        public Builder withSloppyQuorum(boolean sloppyQuorum)
        {
<span class="fc" id="L254">            reqBuilder.setSloppyQuorum(sloppyQuorum);</span>
<span class="fc" id="L255">            return this;</span>
        }

        public DtUpdateOperation build()
        {
<span class="pc bpc" id="L260" title="3 of 4 branches missed.">            if (removeOpPresent &amp;&amp; !reqBuilder.hasContext())</span>
            {
<span class="nc" id="L262">                throw new IllegalStateException(&quot;Remove operations cannot be performed without a context.&quot;);</span>
            }

<span class="fc" id="L265">            return new DtUpdateOperation(this);</span>
        }

        RiakDtPB.CounterOp getCounterOp(CounterOp op)
        {
<span class="fc" id="L270">            return RiakDtPB.CounterOp.newBuilder()</span>
<span class="fc" id="L271">                .setIncrement(op.getIncrement())</span>
<span class="fc" id="L272">                .build();</span>
        }

        RiakDtPB.SetOp getSetOp(SetOp op)
        {
<span class="fc" id="L277">            RiakDtPB.SetOp.Builder setOpBuilder = RiakDtPB.SetOp.newBuilder();</span>

<span class="fc bfc" id="L279" title="All 2 branches covered.">            for (BinaryValue element : op.getAdds())</span>
            {
<span class="fc" id="L281">                setOpBuilder.addAdds(ByteString.copyFrom(element.unsafeGetValue()));</span>
<span class="fc" id="L282">            }</span>

<span class="fc bfc" id="L284" title="All 2 branches covered.">            for (BinaryValue element : op.getRemoves())</span>
            {
<span class="fc" id="L286">                setOpBuilder.addRemoves(ByteString.copyFrom(element.unsafeGetValue()));</span>
<span class="fc" id="L287">            }</span>

<span class="fc bfc" id="L289" title="All 2 branches covered.">            if (setOpBuilder.getRemovesCount() &gt; 0)</span>
            {
<span class="fc" id="L291">                removeOpPresent = true;</span>
            }
<span class="fc" id="L293">            return setOpBuilder.build();</span>
        }

        RiakDtPB.HllOp getHllOp(HllOp op)
        {
<span class="nc" id="L298">            RiakDtPB.HllOp.Builder hllOpBuilder = RiakDtPB.HllOp.newBuilder();</span>

<span class="nc bnc" id="L300" title="All 2 branches missed.">            for (BinaryValue element : op.getElements())</span>
            {
<span class="nc" id="L302">                hllOpBuilder.addAdds(ByteString.copyFrom(element.unsafeGetValue()));</span>
<span class="nc" id="L303">            }</span>

<span class="nc" id="L305">            return hllOpBuilder.build();</span>
        }

        RiakDtPB.MapUpdate.FlagOp getFlagOp(FlagOp op)
        {
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">            return op.getEnabled()</span>
                ? RiakDtPB.MapUpdate.FlagOp.ENABLE
                : RiakDtPB.MapUpdate.FlagOp.DISABLE;
        }

        ByteString getRegisterOp(RegisterOp op)
        {
<span class="fc" id="L317">            return ByteString.copyFrom(op.getValue().unsafeGetValue());</span>
        }

        RiakDtPB.MapField getMapField(MapOp.MapField field)
        {
<span class="fc" id="L322">            RiakDtPB.MapField.Builder mapFieldBuilder = RiakDtPB.MapField.newBuilder();</span>

<span class="pc bpc" id="L324" title="1 of 6 branches missed.">            switch (field.type)</span>
            {
                case SET:
<span class="fc" id="L327">                    mapFieldBuilder.setType(RiakDtPB.MapField.MapFieldType.SET);</span>
<span class="fc" id="L328">                    break;</span>
                case REGISTER:
<span class="fc" id="L330">                    mapFieldBuilder.setType(RiakDtPB.MapField.MapFieldType.REGISTER);</span>
<span class="fc" id="L331">                    break;</span>
                case MAP:
<span class="fc" id="L333">                    mapFieldBuilder.setType(RiakDtPB.MapField.MapFieldType.MAP);</span>
<span class="fc" id="L334">                    break;</span>
                case FLAG:
<span class="fc" id="L336">                    mapFieldBuilder.setType(RiakDtPB.MapField.MapFieldType.FLAG);</span>
<span class="fc" id="L337">                    break;</span>
                case COUNTER:
<span class="fc" id="L339">                    mapFieldBuilder.setType(RiakDtPB.MapField.MapFieldType.COUNTER);</span>
<span class="fc" id="L340">                    break;</span>
                default:
            }
<span class="fc" id="L343">            mapFieldBuilder.setName(ByteString.copyFrom(field.key.unsafeGetValue()));</span>
<span class="fc" id="L344">            return mapFieldBuilder.build();</span>
        }

        RiakDtPB.MapOp getMapOp(MapOp op)
        {
<span class="fc" id="L349">            RiakDtPB.MapOp.Builder mapOpBuilder = RiakDtPB.MapOp.newBuilder();</span>

<span class="pc bpc" id="L351" title="1 of 2 branches missed.">            for (MapOp.MapField field : op.getRemoves())</span>
            {
<span class="nc" id="L353">                mapOpBuilder.addRemoves(getMapField(field));</span>
<span class="nc" id="L354">            }</span>

<span class="pc bpc" id="L356" title="1 of 2 branches missed.">            if (mapOpBuilder.getRemovesCount() &gt; 0)</span>
            {
<span class="nc" id="L358">                removeOpPresent = true;</span>
            }

<span class="fc bfc" id="L361" title="All 2 branches covered.">            for (MapOp.MapUpdate update : op.getUpdates())</span>
            {
                RiakDtPB.MapUpdate.Builder mapUpdateBuilder =
<span class="fc" id="L364">                    RiakDtPB.MapUpdate.newBuilder();</span>

<span class="pc bpc" id="L366" title="1 of 6 branches missed.">                switch (update.field.type)</span>
                {
                    case COUNTER:
<span class="fc" id="L369">                        mapUpdateBuilder.setCounterOp(getCounterOp((CounterOp) update.op));</span>
<span class="fc" id="L370">                        break;</span>
                    case FLAG:
<span class="fc" id="L372">                        mapUpdateBuilder.setFlagOp(getFlagOp((FlagOp) update.op));</span>
<span class="fc" id="L373">                        break;</span>
                    case MAP:
<span class="fc" id="L375">                        mapUpdateBuilder.setMapOp(getMapOp((MapOp) update.op));</span>
<span class="fc" id="L376">                        break;</span>
                    case REGISTER:
<span class="fc" id="L378">                        mapUpdateBuilder.setRegisterOp(getRegisterOp((RegisterOp) update.op));</span>
<span class="fc" id="L379">                        break;</span>
                    case SET:
<span class="fc" id="L381">                        mapUpdateBuilder.setSetOp(getSetOp((SetOp) update.op));</span>
<span class="fc" id="L382">                        break;</span>
                    default:
<span class="nc" id="L384">                        throw new IllegalStateException(&quot;Unknow datatype encountered&quot;);</span>
                }

<span class="fc" id="L387">                mapUpdateBuilder.setField(getMapField(update.field));</span>
<span class="fc" id="L388">                mapOpBuilder.addUpdates(mapUpdateBuilder);</span>
<span class="fc" id="L389">            }</span>

<span class="fc" id="L391">            return mapOpBuilder.build();</span>
        }

        /**
         * Add an update op to this operation
         *
         * @param op the update
         * @return this
         */
        public Builder withOp(CrdtOp op)
        {
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">            if (op instanceof CounterOp)</span>
            {
<span class="nc" id="L404">                withOp((CounterOp) op);</span>
            }
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">            else if (op instanceof MapOp)</span>
            {
<span class="fc" id="L408">                withOp((MapOp) op);</span>
            }
<span class="nc bnc" id="L410" title="All 2 branches missed.">            else if (op instanceof SetOp)</span>
            {
<span class="nc" id="L412">                withOp((SetOp) op);</span>
            }
<span class="nc bnc" id="L414" title="All 2 branches missed.">            else if (op instanceof HllOp)</span>
            {
<span class="nc" id="L416">                withOp((HllOp) op);</span>
            }

<span class="fc" id="L419">            return this;</span>
        }

        private Builder withOp(CounterOp op)
        {
<span class="nc" id="L424">            reqBuilder.setOp(RiakDtPB.DtOp.newBuilder()</span>
<span class="nc" id="L425">                .setCounterOp(getCounterOp(op)));</span>

<span class="nc" id="L427">            return this;</span>
        }

        private Builder withOp(MapOp op)
        {
<span class="fc" id="L432">            reqBuilder.setOp(RiakDtPB.DtOp.newBuilder()</span>
<span class="fc" id="L433">                .setMapOp(getMapOp(op)));</span>
<span class="fc" id="L434">            return this;</span>
        }

        private Builder withOp(SetOp op)
        {
<span class="nc" id="L439">            reqBuilder.setOp(RiakDtPB.DtOp.newBuilder()</span>
<span class="nc" id="L440">                .setSetOp(getSetOp(op)));</span>

<span class="nc" id="L442">            return this;</span>
        }

        private Builder withOp(HllOp op)
        {
<span class="nc" id="L447">            reqBuilder.setOp(RiakDtPB.DtOp.newBuilder()</span>
<span class="nc" id="L448">                .setHllOp(getHllOp(op)));</span>
<span class="nc" id="L449">            return this;</span>
        }
    }

    public static class Response extends DtFetchOperation.Response
    {
        private final BinaryValue generatedKey;

        private Response(Init&lt;?&gt; builder)
        {
<span class="nc" id="L459">            super(builder);</span>
<span class="nc" id="L460">            this.generatedKey = builder.generatedKey;</span>
<span class="nc" id="L461">        }</span>

        public boolean hasGeneratedKey()
        {
<span class="nc bnc" id="L465" title="All 2 branches missed.">            return generatedKey != null;</span>
        }

        public BinaryValue getGeneratedKey()
        {
<span class="nc" id="L470">            return generatedKey;</span>
        }

<span class="nc" id="L473">        protected static abstract class Init&lt;T extends Init&lt;T&gt;&gt; extends DtFetchOperation.Response.Init&lt;T&gt;</span>
        {
            private BinaryValue generatedKey;

            T withGeneratedKey(BinaryValue generatedKey)
            {
<span class="nc" id="L479">                this.generatedKey = generatedKey;</span>
<span class="nc" id="L480">                return self();</span>
            }
        }

<span class="nc" id="L484">        static class Builder extends Init&lt;Builder&gt;</span>
        {
            @Override
            protected Builder self()
            {
<span class="nc" id="L489">                return this;</span>
            }

            @Override
            protected Response build()
            {
<span class="nc" id="L495">                return new Response(this);</span>
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>