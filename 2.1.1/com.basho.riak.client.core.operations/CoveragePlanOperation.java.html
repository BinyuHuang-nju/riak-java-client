<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CoveragePlanOperation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Riak Client for Java</a> &gt; <a href="index.source.html" class="el_package">com.basho.riak.client.core.operations</a> &gt; <span class="el_source">CoveragePlanOperation.java</span></div><h1>CoveragePlanOperation.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2013-2015 Basho Technologies Inc
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.basho.riak.client.core.operations;

import com.basho.riak.client.core.FutureOperation;
import com.basho.riak.client.core.RiakMessage;
import com.basho.riak.client.core.query.Namespace;
import com.basho.riak.client.core.util.HostAndPort;
import com.basho.riak.protobuf.RiakKvPB;
import com.basho.riak.protobuf.RiakMessageCodes;
import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import org.slf4j.LoggerFactory;

import java.io.Serializable;
import java.util.*;

/**
 * An operation to retrieve a coverage plan from Riak.
 *
 * @author Sergey Galkin &lt;sgalkin at basho dot com&gt;
 */
public class CoveragePlanOperation extends FutureOperation&lt;CoveragePlanOperation.Response, RiakKvPB.RpbCoverageResp, Namespace&gt;
{
    private final RiakKvPB.RpbCoverageReq.Builder reqBuilder;
    private final Namespace namespace;

    private CoveragePlanOperation(AbstractBuilder builder)
<span class="fc" id="L42">    {</span>
<span class="fc" id="L43">        this.reqBuilder = builder.reqBuilder;</span>
<span class="fc" id="L44">        namespace = builder.namespace;</span>
<span class="fc" id="L45">    }</span>

    @Override
    protected Response convert(List&lt;RiakKvPB.RpbCoverageResp&gt; rawResponse)
    {
<span class="fc" id="L50">        Response r = new Response();</span>
<span class="pc bpc" id="L51" title="1 of 2 branches missed.">        for (RiakKvPB.RpbCoverageResp resp : rawResponse)</span>
        {
<span class="pc bpc" id="L53" title="1 of 2 branches missed.">            for (RiakKvPB.RpbCoverageEntry e: resp.getEntriesList())</span>
            {
<span class="fc" id="L55">                final Response.CoverageEntry ce = new Response.CoverageEntry();</span>
<span class="fc" id="L56">                ce.coverageContext = e.getCoverContext().toByteArray();</span>
<span class="fc" id="L57">                ce.description = e.getKeyspaceDesc().toStringUtf8();</span>
<span class="fc" id="L58">                ce.host = e.getIp().toStringUtf8();</span>
<span class="fc" id="L59">                ce.port = e.getPort();</span>

<span class="pc bpc" id="L61" title="1 of 2 branches missed.">                if (&quot;0.0.0.0&quot;.equals(ce.getHost()))</span>
                {
<span class="fc" id="L63">                    LoggerFactory.getLogger(CoveragePlanOperation.class).error(</span>
                            &quot;CoveragePlanOperation returns at least one coverage entry: '{}' -- with IP address '0.0.0.0'.\n&quot; +
                                &quot;Execution will be failed due to the imposibility of using IP '0.0.0.0' &quot; +
                                &quot;for querying data from the remote Riak.&quot;,
<span class="fc" id="L67">                            ce.description);</span>

<span class="fc" id="L69">                    throw new RuntimeException(&quot;CoveragePlanOperation returns at least one coverage entry with ip '0.0.0.0'.&quot;);</span>
                }

<span class="nc" id="L72">                r.addEntry(ce);</span>
<span class="nc" id="L73">            }</span>
<span class="nc" id="L74">        }</span>
<span class="nc" id="L75">        return r;</span>
    }

    @Override
    protected RiakMessage createChannelMessage()
    {
<span class="nc" id="L81">        return new RiakMessage(RiakMessageCodes.MSG_CoverageReq, reqBuilder.build().toByteArray());</span>
    }

    @Override
    protected RiakKvPB.RpbCoverageResp decode(RiakMessage rawMessage)
    {
        try
        {
<span class="nc" id="L89">            Operations.checkPBMessageType(rawMessage, RiakMessageCodes.MSG_CoverageResp);</span>
<span class="nc" id="L90">            return RiakKvPB.RpbCoverageResp.parseFrom(rawMessage.getData());</span>
        }
<span class="nc" id="L92">        catch (InvalidProtocolBufferException e)</span>
        {
<span class="nc" id="L94">            throw new IllegalArgumentException(&quot;Invalid message received&quot;, e);</span>
        }
    }

    @Override
    public Namespace getQueryInfo()
    {
<span class="nc" id="L101">        return namespace;</span>
    }

    public static abstract class AbstractBuilder&lt;R&gt;
    {
<span class="fc" id="L106">        private final RiakKvPB.RpbCoverageReq.Builder reqBuilder = RiakKvPB.RpbCoverageReq.newBuilder();</span>
        private Namespace namespace;

        public AbstractBuilder(Namespace ns)
<span class="fc" id="L110">        {</span>
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">            if (ns == null)</span>
            {
<span class="nc" id="L113">                throw new IllegalArgumentException(&quot;Namespace can not be null&quot;);</span>
            }

<span class="fc" id="L116">            reqBuilder.setType(ByteString.copyFrom(ns.getBucketType().unsafeGetValue()));</span>
<span class="fc" id="L117">            reqBuilder.setBucket(ByteString.copyFrom(ns.getBucketName().unsafeGetValue()));</span>

<span class="fc" id="L119">            namespace = ns;</span>
<span class="fc" id="L120">        }</span>

        public AbstractBuilder&lt;R&gt; withMinPartitions(int minPartitions)
        {
<span class="nc" id="L124">            reqBuilder.setMinPartitions(minPartitions);</span>
<span class="nc" id="L125">            return this;</span>
        }

        public AbstractBuilder&lt;R&gt; withReplaceCoverageEntry(Response.CoverageEntry coverageEntry)
        {
<span class="nc" id="L130">            return withReplaceCoverageContext(coverageEntry.getCoverageContext());</span>
        }

        public AbstractBuilder&lt;R&gt; withReplaceCoverageContext(byte[] coverageContext)
        {
<span class="nc" id="L135">            reqBuilder.setReplaceCover(ByteString.copyFrom(coverageContext));</span>
<span class="nc" id="L136">            return this;</span>
        }

        public AbstractBuilder&lt;R&gt; withUnavailableCoverageContext(Iterable&lt;byte[]&gt; coverageContext)
        {
<span class="nc bnc" id="L141" title="All 2 branches missed.">            for (byte[] aCoverageContext : coverageContext)</span>
            {
<span class="nc" id="L143">                withUnavailableCoverageContext(aCoverageContext);</span>
<span class="nc" id="L144">            }</span>
<span class="nc" id="L145">            return this;</span>
        }

        public AbstractBuilder&lt;R&gt; withUnavailableCoverageEntries(Iterable&lt;Response.CoverageEntry&gt; coverageEntries)
        {
<span class="nc bnc" id="L150" title="All 2 branches missed.">            for (Response.CoverageEntry coverageEntry : coverageEntries)</span>
            {
<span class="nc" id="L152">                withUnavailableCoverageContext(coverageEntry.getCoverageContext());</span>
<span class="nc" id="L153">            }</span>
<span class="nc" id="L154">            return this;</span>
        }

        public AbstractBuilder&lt;R&gt; withUnavailableCoverageContext(byte[]...coverageContext)
        {
<span class="nc bnc" id="L159" title="All 2 branches missed.">            for (byte[] cc: coverageContext)</span>
            {
<span class="nc" id="L161">                reqBuilder.addUnavailableCover(ByteString.copyFrom(cc));</span>
            }
<span class="nc" id="L163">            return this;</span>
        }

        public CoveragePlanOperation buildOperation()
        {
<span class="fc" id="L168">            return new CoveragePlanOperation(this);</span>
        }

        public abstract R build();

        public Namespace getNamespace()
        {
<span class="nc" id="L175">            return namespace;</span>
        }
    }

    public static class Response implements Iterable&lt;Response.CoverageEntry&gt;
    {
<span class="fc" id="L181">        public static class CoverageEntry implements Serializable</span>
        {
            private static final long serialVersionUID = 0;
            private String host;
            private int port;

            /**
             * Some human readable description of the keyspace covered
             */
            private String description;

            /**
             *  Opaque context to pass into 2I query
             */
            private byte[] coverageContext;

            public String getHost()
            {
<span class="fc" id="L199">                return host;</span>
            }

            public int getPort()
            {
<span class="nc" id="L204">                return port;</span>
            }

            public String getDescription()
            {
<span class="nc" id="L209">                return description;</span>
            }

            public byte[] getCoverageContext()
            {
<span class="nc" id="L214">                return coverageContext;</span>
            }

            @Override
            public boolean equals(Object o)
            {
<span class="nc bnc" id="L220" title="All 2 branches missed.">                if (this == o) return true;</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">                if (!(o instanceof CoverageEntry)) return false;</span>

<span class="nc" id="L223">                CoverageEntry that = (CoverageEntry) o;</span>

<span class="nc bnc" id="L225" title="All 2 branches missed.">                if (getPort() != that.getPort()) return false;</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">                if (!getHost().equals(that.getHost())) return false;</span>
<span class="nc" id="L227">                return Arrays.equals(getCoverageContext(), that.getCoverageContext());</span>
            }

            @Override
            public int hashCode()
            {
<span class="nc" id="L233">                int result = getHost().hashCode();</span>
<span class="nc" id="L234">                result = 31 * result + getPort();</span>
<span class="nc" id="L235">                result = 31 * result + Arrays.hashCode(getCoverageContext());</span>
<span class="nc" id="L236">                return result;</span>
            }

            @Override
            public String toString()
            {
<span class="nc" id="L242">                return &quot;CoverageEntry{&quot; +</span>
                        &quot;description='&quot; + description + '\'' +
                        '}';
            }
        }

<span class="pc" id="L248">        private HashMap&lt;HostAndPort, List&lt;CoverageEntry&gt;&gt; perHostCoverage = new HashMap&lt;&gt;();</span>

        protected Response()
<span class="fc" id="L251">        {</span>
<span class="fc" id="L252">        }</span>

        protected Response(Response rhs)
<span class="nc" id="L255">        {</span>
<span class="nc" id="L256">            this.perHostCoverage.putAll(rhs.perHostCoverage);</span>
<span class="nc" id="L257">        }</span>

        public Set&lt;HostAndPort&gt; hosts()
        {
<span class="nc" id="L261">            return perHostCoverage.keySet();</span>
        }

        public List&lt;CoverageEntry&gt; hostEntries(HostAndPort host)
        {
<span class="nc" id="L266">            final List&lt;CoverageEntry&gt; lst = perHostCoverage.get(host);</span>

<span class="nc bnc" id="L268" title="All 2 branches missed.">            if (lst == null)</span>
            {
<span class="nc" id="L270">                return Collections.emptyList();</span>
            }

<span class="nc" id="L273">            return lst;</span>
        }

        public List&lt;CoverageEntry&gt; hostEntries(String host, int port)
        {
<span class="nc" id="L278">            return hostEntries(HostAndPort.fromParts(host, port));</span>
        }

        private static &lt;T&gt;  Iterator&lt;T&gt; emptyIterator()
        {
<span class="nc" id="L283">            return Collections.&lt;T&gt;emptyList().iterator();</span>
        }

        @Override
        public Iterator&lt;CoverageEntry&gt; iterator()
        {
<span class="nc" id="L289">            final Iterator&lt;List&lt;CoverageEntry&gt;&gt; itor = perHostCoverage.values().iterator();</span>

<span class="nc" id="L291">            return new Iterator&lt;CoverageEntry&gt;()</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">            {</span>
<span class="nc" id="L293">                Iterator&lt;CoverageEntry&gt; subIterator = null;</span>

                @Override
                public boolean hasNext()
                {
<span class="nc bnc" id="L298" title="All 4 branches missed.">                    if (subIterator == null || !subIterator.hasNext())</span>
                    {
<span class="nc bnc" id="L300" title="All 2 branches missed.">                        if (itor.hasNext())</span>
                        {
<span class="nc" id="L302">                            subIterator = itor.next().iterator();</span>
                        }
                        else
                        {
<span class="nc" id="L306">                            subIterator = emptyIterator();</span>
<span class="nc" id="L307">                            return false;</span>
                        }
                    }

<span class="nc" id="L311">                    return subIterator.hasNext();</span>
                }

                @Override
                public CoverageEntry next()
                {
<span class="nc bnc" id="L317" title="All 2 branches missed.">                    if (!hasNext())</span>
                    {
<span class="nc" id="L319">                        throw new NoSuchElementException();</span>
                    }

<span class="nc bnc" id="L322" title="All 4 branches missed.">                    assert subIterator != null;</span>
<span class="nc" id="L323">                    return subIterator.next();</span>
                }

                @Override
                public void remove()
                {
<span class="nc" id="L329">                    throw new UnsupportedOperationException();</span>
                }
            };
        }

        private void addEntry(CoverageEntry coverageEntry)
        {
<span class="nc" id="L336">            final HostAndPort key = HostAndPort.fromParts(coverageEntry.getHost(), coverageEntry.getPort());</span>
<span class="nc" id="L337">            List&lt;CoverageEntry&gt; lst =  perHostCoverage.get(key);</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">            if (lst == null)</span>
            {
<span class="nc" id="L340">                lst = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L341">                perHostCoverage.put(key, lst);</span>
            }
<span class="nc" id="L343">            lst.add(coverageEntry);</span>
<span class="nc" id="L344">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>