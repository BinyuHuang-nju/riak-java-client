<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Converter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Riak Client for Java</a> &gt; <a href="index.source.html" class="el_package">com.basho.riak.client.api.convert</a> &gt; <span class="el_source">Converter.java</span></div><h1>Converter.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2013 Basho Technologies Inc
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.basho.riak.client.api.convert;

import com.basho.riak.client.api.convert.reflection.AnnotationUtil;
import com.basho.riak.client.api.cap.VClock;
import com.basho.riak.client.core.query.Location;
import com.basho.riak.client.core.query.Namespace;
import com.basho.riak.client.core.query.RiakObject;
import com.basho.riak.client.core.util.BinaryValue;
import java.lang.reflect.Constructor;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;

/**
 * The Converter acts as a bridge between the core and the user level API, specifically
 * for ORM.
 * &lt;p&gt;
 * Subclasses will override the {@link #fromDomain(java.lang.Object) } and
 * {@link #fromDomain(java.lang.Object) } methods to convert the value portion
 * of a {@code RiakObject} to a domain object.
 * &lt;/p&gt;
 *
 * @author Brian Roach &lt;roach at basho dot com&gt;
 * @param &lt;T&gt; the type to convert to
 * @since 2.0
 */
public abstract class Converter&lt;T&gt;
{
    protected final Type type;

    public Converter(Type type)
<span class="fc" id="L46">    {</span>
<span class="fc" id="L47">        this.type = type;</span>
<span class="fc" id="L48">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    protected final T newDomainInstance()
    {
        try
        {
<span class="nc bnc" id="L55" title="All 2 branches missed.">            Class&lt;?&gt; rawType = type instanceof Class&lt;?&gt;</span>
                ? (Class&lt;?&gt;) type
<span class="nc" id="L57">                : (Class&lt;?&gt;) ((ParameterizedType) type).getRawType();</span>
<span class="nc" id="L58">            Constructor&lt;?&gt; constructor = rawType.getConstructor();</span>
<span class="nc" id="L59">            return (T) constructor.newInstance();</span>
        }
<span class="nc" id="L61">        catch (Exception ex)</span>
        {
<span class="nc" id="L63">            throw new ConversionException(ex);</span>
        }
    }

    /**
     * Converts from a RiakObject to a domain object.
     *
     * @param obj the RiakObject to be converted
     * @param location The location of this RiakObject in Riak
     * @return an instance of the domain type T
     */
    public T toDomain(RiakObject obj, Location location)
    {
        T domainObject;
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">        if (obj.isDeleted())</span>
        {
<span class="nc" id="L79">            domainObject = newDomainInstance();</span>
        }
        else
        {
<span class="fc" id="L83">            domainObject = toDomain(obj.getValue(), obj.getContentType());</span>

<span class="fc" id="L85">            AnnotationUtil.populateIndexes(obj.getIndexes(), domainObject);</span>
<span class="fc" id="L86">            AnnotationUtil.populateLinks(obj.getLinks(), domainObject);</span>
<span class="fc" id="L87">            AnnotationUtil.populateUsermeta(obj.getUserMeta(), domainObject);</span>
<span class="fc" id="L88">            AnnotationUtil.setContentType(domainObject, obj.getContentType());</span>
<span class="fc" id="L89">            AnnotationUtil.setVTag(domainObject, obj.getVTag());</span>
        }

<span class="fc" id="L92">        AnnotationUtil.setKey(domainObject, location.getKey());</span>
<span class="fc" id="L93">        AnnotationUtil.setBucketName(domainObject, location.getNamespace().getBucketName());</span>
<span class="fc" id="L94">        AnnotationUtil.setBucketType(domainObject, location.getNamespace().getBucketType());</span>

<span class="fc" id="L96">        AnnotationUtil.setVClock(domainObject, obj.getVClock());</span>
<span class="fc" id="L97">        AnnotationUtil.setTombstone(domainObject, obj.isDeleted());</span>
<span class="fc" id="L98">        AnnotationUtil.setLastModified(domainObject, obj.getLastModified());</span>

<span class="fc" id="L100">        return domainObject;</span>
    }

    /**
     * Convert the value portion of a RiakObject to a domain object.
     * &lt;p&gt;
     * Implementations override this method to convert the value contained in
     * a {@code RiakObject} to an instance of a domain object.
     * &lt;/p&gt;
     * @param value the value portion of a RiakObject to convert to a domain object
     * @param contentType The content type of the RiakObject
     * @return a new instance of the domain object
     */
    public abstract T toDomain(BinaryValue value, String contentType) throws ConversionException;

    /**
     * Convert from a domain object to a RiakObject.
     * &lt;p&gt;
     * The domain object itself may be completely annotated with everything
     * required to produce a RiakObject except for the value portion.
     * This will prefer annotated
     * items over the {@code Location} passed in.
     * &lt;/p&gt;
     * @param domainObject a domain object to be stored in Riak.
     * @param namespace the namespace in Riak
     * @param key the key for the object
     * @return data to be stored in Riak.
     */
    public OrmExtracted fromDomain(T domainObject, Namespace namespace, BinaryValue key)
    {
<span class="fc bfc" id="L130" title="All 2 branches covered.">        BinaryValue bucketName = namespace != null ? namespace.getBucketName() : null;</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">        BinaryValue bucketType = namespace != null ? namespace.getBucketType() : null;</span>

<span class="fc" id="L133">        key = AnnotationUtil.getKey(domainObject, key);</span>
<span class="fc" id="L134">        bucketName = AnnotationUtil.getBucketName(domainObject, bucketName);</span>
<span class="fc" id="L135">        bucketType = AnnotationUtil.getBucketType(domainObject, bucketType);</span>

<span class="pc bpc" id="L137" title="1 of 2 branches missed.">        if (bucketName == null)</span>
        {
<span class="nc" id="L139">            throw new ConversionException(&quot;Bucket name not provided via namespace or domain object&quot;);</span>
        }

<span class="fc" id="L142">        VClock vclock = AnnotationUtil.getVClock(domainObject);</span>
<span class="fc" id="L143">        String contentType =</span>
<span class="fc" id="L144">            AnnotationUtil.getContentType(domainObject, RiakObject.DEFAULT_CONTENT_TYPE);</span>

<span class="fc" id="L146">        RiakObject riakObject = new RiakObject();</span>

<span class="fc" id="L148">        AnnotationUtil.getUsermetaData(riakObject.getUserMeta(), domainObject);</span>
<span class="fc" id="L149">        AnnotationUtil.getIndexes(riakObject.getIndexes(), domainObject);</span>
<span class="fc" id="L150">        AnnotationUtil.getLinks(riakObject.getLinks(), domainObject);</span>

<span class="fc" id="L152">        ContentAndType cAndT = fromDomain(domainObject);</span>
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">        contentType = cAndT.contentType != null ? cAndT.contentType : contentType;</span>

<span class="fc" id="L155">        riakObject.setContentType(contentType)</span>
<span class="fc" id="L156">                    .setValue(cAndT.content)</span>
<span class="fc" id="L157">                    .setVClock(vclock);</span>

        // We allow an annotated object to omit @BucketType and get the default
        Namespace ns;
<span class="fc bfc" id="L161" title="All 2 branches covered.">        if (bucketType == null)</span>
        {
<span class="fc" id="L163">            ns = new Namespace(bucketName);</span>
        }
        else
        {
<span class="fc" id="L167">            ns = new Namespace(bucketType, bucketName);</span>
        }

<span class="fc" id="L170">        OrmExtracted extracted = new OrmExtracted(riakObject, ns, key);</span>
<span class="fc" id="L171">        return extracted;</span>
    }

    /**
     * Provide the value portion of a RiakObject from the domain object.
     * &lt;p&gt;
     * Implementations override this method to provide the value portion of the
     * RiakObject to be stored from the supplied domain object.
     * &lt;/p&gt;
     * @param domainObject the domain object.
     * @return A BinaryValue to be stored in Riak
     */
    public abstract ContentAndType fromDomain(T domainObject) throws ConversionException;

    /**
     * Encapsulation of ORM data extracted from a domain object.
     * &lt;p&gt;
     * This allows for user-defined POJOs to encapsulate everything required to
     * query Riak.
     *&lt;/p&gt;
     *
     */
    public static class OrmExtracted
    {
        private final RiakObject riakObject;
        private final Namespace namespace;
        private final BinaryValue key;

        public OrmExtracted(RiakObject riakObject, Namespace namespace, BinaryValue key)
<span class="fc" id="L200">        {</span>
<span class="fc" id="L201">            this.riakObject = riakObject;</span>
<span class="fc" id="L202">            this.namespace = namespace;</span>
<span class="fc" id="L203">            this.key = key;</span>
<span class="fc" id="L204">        }</span>

        /**
         * @return the riakObject
         */
        public RiakObject getRiakObject()
        {
<span class="fc" id="L211">            return riakObject;</span>
        }

        /**
         * @return the namespace
         */
        public Namespace getNamespace()
        {
<span class="fc" id="L219">            return namespace;</span>
        }

        public boolean hasKey()
        {
<span class="nc bnc" id="L224" title="All 2 branches missed.">            return key != null;</span>
        }

        public BinaryValue getKey()
        {
<span class="fc" id="L229">            return key;</span>
        }
    }

    protected class ContentAndType
    {
        private final BinaryValue content;
        private final String contentType;

        public ContentAndType(BinaryValue content, String contentType)
<span class="fc" id="L239">        {</span>
<span class="fc" id="L240">            this.content = content;</span>
<span class="fc" id="L241">            this.contentType = contentType;</span>
<span class="fc" id="L242">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>