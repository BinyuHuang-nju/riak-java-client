<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ChunkedResponseIterator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Riak Client for Java</a> &gt; <a href="index.source.html" class="el_package">com.basho.riak.client.api.commands</a> &gt; <span class="el_source">ChunkedResponseIterator.java</span></div><h1>ChunkedResponseIterator.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2016 Basho Technologies, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.basho.riak.client.api.commands;

import com.basho.riak.client.core.StreamingRiakFuture;
import com.basho.riak.client.core.util.BinaryValue;

import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TransferQueue;
import java.util.function.Function;

/**
 * Transforms a stream of response chunks to a Iterable of response items.
 *
 * When iterating over this class's {@link Iterator} this class will lazily walk
 * through the response chunks's iterators and convert the items.
 * It will also wait for more response chunks if none are available.
 *
 * Since this class polls for new &quot;streaming&quot; data, it is advisable
 * to check {@link Thread#isInterrupted()} while using this class's
 * {@link Iterator} in environments where thread interrupts must be obeyed.
 *
 * @param &lt;FinalT&gt; The final converted type that this class exposes as part of its iterator.
 * @param &lt;ChunkT&gt; The type of the response chunks, contains an Iterable&amp;lt;&lt;b&gt;CoreT&lt;/b&gt;&amp;gt;
 * @param &lt;CoreT&gt; The raw response type, will get converted to &lt;b&gt;FinalT&lt;/b&gt;.
 * @author Alex Moore &lt;amoore at basho.com&gt;
 * @author Sergey Galkin &lt;srggal at gmail dot com&gt;
 * @since 2.1.0
 */
public class ChunkedResponseIterator&lt;FinalT, ChunkT extends Iterable&lt;CoreT&gt;, CoreT&gt; implements Iterator&lt;FinalT&gt;
{
    private final int timeout;
<span class="fc" id="L49">    private volatile BinaryValue continuation = null;</span>
    private final StreamingRiakFuture&lt;ChunkT, ?&gt; coreFuture;
    private final TransferQueue&lt;ChunkT&gt; chunkQueue;
    private final Function&lt;CoreT, FinalT&gt; createNext;
    private final Function&lt;ChunkT, Iterator&lt;CoreT&gt;&gt; getNextIterator;
    private final Function&lt;ChunkT, BinaryValue&gt; getContinuationFn;

<span class="fc" id="L56">    protected Iterator&lt;CoreT&gt; currentIterator = null;</span>

    public ChunkedResponseIterator(StreamingRiakFuture&lt;ChunkT, ?&gt; coreFuture,
                                   int pollTimeout,
                                   Function&lt;CoreT, FinalT&gt; createNextFn,
                                   Function&lt;ChunkT, Iterator&lt;CoreT&gt;&gt; getNextIteratorFn)
    {
<span class="fc" id="L63">        this(coreFuture, pollTimeout, createNextFn, getNextIteratorFn, (x) -&gt; null);</span>
<span class="fc" id="L64">    }</span>

    public ChunkedResponseIterator(StreamingRiakFuture&lt;ChunkT, ?&gt; coreFuture,
                                   int pollTimeout,
                                   Function&lt;CoreT, FinalT&gt; createNextFn,
                                   Function&lt;ChunkT, Iterator&lt;CoreT&gt;&gt; getNextIteratorFn,
                                   Function&lt;ChunkT, BinaryValue&gt; getContinuationFn)
<span class="fc" id="L71">    {</span>
<span class="fc" id="L72">        this.timeout = pollTimeout;</span>
<span class="fc" id="L73">        this.coreFuture = coreFuture;</span>
<span class="fc" id="L74">        this.chunkQueue = coreFuture.getResultsQueue();</span>
<span class="fc" id="L75">        this.createNext = createNextFn;</span>
<span class="fc" id="L76">        this.getNextIterator = getNextIteratorFn;</span>
<span class="fc" id="L77">        this.getContinuationFn = getContinuationFn;</span>

        // to kick of initial loading
<span class="fc" id="L80">        hasNext();</span>
<span class="fc" id="L81">    }</span>

    /**
     * Returns {@code true} if the iteration has more elements.
     * (In other words, returns {@code true} if {@link #next} would
     * return an element rather than throwing an exception.)
     *
     * This method will block and wait for more data if none is immediately available.
     *
     * &lt;b&gt;Riak Java Client Note:&lt;/b&gt; Since this class polls for
     * new &quot;streaming&quot; data, it is advisable to check {@link Thread#isInterrupted()}
     * in environments where thread interrupts must be obeyed.
     *
     * @return {@code true} if the iteration has more elements
     */
    @Override
    public boolean hasNext()
    {
        // Check &amp; clear interrupted flag so we don't get an
        // InterruptedException every time if the user
        // doesn't clear it / deal with it.
<span class="fc" id="L102">        boolean interrupted = Thread.interrupted();</span>
<span class="fc" id="L103">        Boolean dataLoaded = null;</span>

        try
        {
<span class="fc bfc" id="L107" title="All 4 branches covered.">            while (!currentIteratorHasNext() &amp;&amp; dataLoaded == null)</span>
            {
                try
                {
<span class="fc" id="L111">                    dataLoaded = tryLoadNextChunkIterator();</span>
                }
<span class="fc" id="L113">                catch (InterruptedException ex)</span>
                {
<span class="fc" id="L115">                    interrupted = true;</span>
<span class="fc" id="L116">                }</span>
            }
<span class="fc" id="L118">            return currentIteratorHasNext();</span>
        }
        finally
        {
<span class="pc bpc" id="L122" title="2 of 4 branches missed.">            if (interrupted)</span>
            {
                // Reset interrupted flag if we came in with it
                // or we were interrupted while waiting.
<span class="pc" id="L126">                Thread.currentThread().interrupt();</span>
            }
        }
    }

    private boolean currentIteratorHasNext()
    {
<span class="fc bfc" id="L133" title="All 4 branches covered.">        return currentIterator != null &amp;&amp; currentIterator.hasNext();</span>
    }

    private boolean possibleChunksRemaining()
    {
        // Chunks may remain if :
        // Core Operation Not Done OR items still in chunk Queue
<span class="pc bpc" id="L140" title="1 of 4 branches missed.">        return !coreFuture.isDone() || !chunkQueue.isEmpty();</span>
    }

    /**
     * Returns whether this response contains a continuation.
     * Only run this once the operation is complete, otherwise it will return true as it's
     * @return Whether this response has a continuation.
     */
    public boolean hasContinuation()
    {
<span class="nc bnc" id="L150" title="All 4 branches missed.">        return continuation != null || possibleChunksRemaining();</span>
    }

    /**
     * Returns the current value of the continuation.
     * Only run this once the operation is complete, or else you will get a null value.
     * @return The continuation value (if any).
     */
    public BinaryValue getContinuation()
    {
<span class="nc" id="L160">        return continuation;</span>
    }

    /**
     * Returns the next element in the iteration.
     * This method will block and wait for more data if none is immediately available.
     *
     * &lt;b&gt;Riak Java Client Note:&lt;/b&gt; Since this class polls for
     * new &quot;streaming&quot; data, it is advisable to check {@link Thread#isInterrupted()}
     * in environments where thread interrupts must be obeyed.
     *
     * @return the next element in the iteration
     * @throws NoSuchElementException if the iteration has no more elements
     */
    @Override
    public FinalT next()
    {
<span class="fc bfc" id="L177" title="All 2 branches covered.">        if (hasNext())</span>
        {
<span class="fc" id="L179">            return createNext.apply(currentIterator.next());</span>
        }

<span class="fc" id="L182">        throw new NoSuchElementException();</span>
    }

    private boolean tryLoadNextChunkIterator() throws InterruptedException
    {
<span class="fc" id="L187">        this.currentIterator = null;</span>
<span class="fc" id="L188">        boolean populatedChunkLoaded = false;</span>

<span class="fc bfc" id="L190" title="All 4 branches covered.">        while (!populatedChunkLoaded &amp;&amp; possibleChunksRemaining())</span>
        {
<span class="fc" id="L192">            final ChunkT nextChunk = chunkQueue.poll(timeout, TimeUnit.MILLISECONDS);</span>

<span class="fc bfc" id="L194" title="All 2 branches covered.">            if (nextChunk != null)</span>
            {
<span class="fc" id="L196">                this.currentIterator = getNextIterator.apply(nextChunk);</span>
<span class="fc" id="L197">                populatedChunkLoaded = currentIteratorHasNext();</span>

<span class="fc" id="L199">                loadContinuation(nextChunk);</span>
            }
<span class="fc" id="L201">        }</span>

<span class="fc" id="L203">        return populatedChunkLoaded;</span>
    }

    private void loadContinuation(ChunkT nextChunk)
    {
<span class="fc" id="L208">        final BinaryValue fetchedContinuation = getContinuationFn.apply(nextChunk);</span>
<span class="pc bpc" id="L209" title="2 of 4 branches missed.">        if (this.continuation == null &amp;&amp; fetchedContinuation != null)</span>
        {
<span class="nc" id="L211">            this.continuation = fetchedContinuation;</span>
        }
<span class="fc" id="L213">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>