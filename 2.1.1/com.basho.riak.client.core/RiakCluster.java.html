<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RiakCluster.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Riak Client for Java</a> &gt; <a href="index.source.html" class="el_package">com.basho.riak.client.core</a> &gt; <span class="el_source">RiakCluster.java</span></div><h1>RiakCluster.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2013 Basho Technologies, Inc
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.basho.riak.client.core;

import com.basho.riak.client.core.util.HostAndPort;
import io.netty.bootstrap.Bootstrap;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.nio.NioSocketChannel;

import java.net.UnknownHostException;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A modeled Riak Cluster.
 *
 * &lt;p&gt;
 * This class represents a Riak Cluster upon which operations are executed.
 * Instances are created using the {@link Builder}
 * &lt;/p&gt;
 *
 * @author Brian Roach &lt;roach at basho dot com&gt;
 * @author Sergey Galkin &lt;srggal at gmail dot com&gt;
 * @since 2.0
 */
public class  RiakCluster implements OperationRetrier, NodeStateListener
{
<span class="pc" id="L46">    enum State { CREATED, RUNNING, QUEUING, SHUTTING_DOWN, SHUTDOWN }</span>
<span class="fc" id="L47">    private final Logger logger = LoggerFactory.getLogger(RiakCluster.class);</span>
    private final int executionAttempts;
    private final NodeManager nodeManager;
<span class="fc" id="L50">    private final AtomicInteger inFlightCount = new AtomicInteger();</span>
    private final ScheduledExecutorService executor;
    private final Bootstrap bootstrap;
    private final List&lt;RiakNode&gt; nodeList;
<span class="fc" id="L54">    private final ReentrantReadWriteLock nodeListLock = new ReentrantReadWriteLock();</span>
<span class="fc" id="L55">    private final LinkedBlockingQueue&lt;FutureOperation&gt; retryQueue = new LinkedBlockingQueue&lt;&gt;();</span>
    private final boolean queueOperations;
    private final ConcurrentLinkedDeque&lt;FutureOperation&gt; operationQueue;
    private final RiakNode.Sync operationQueuePermits;
<span class="fc" id="L59">    private final List&lt;NodeStateListener&gt; stateListeners =</span>
<span class="fc" id="L60">        Collections.synchronizedList(new LinkedList&lt;NodeStateListener&gt;());</span>

    private volatile ScheduledFuture&lt;?&gt; shutdownFuture;
    private volatile ScheduledFuture&lt;?&gt; retrierFuture;
    private volatile ScheduledFuture&lt;?&gt; queueDrainFuture;

    private volatile State state;
<span class="fc" id="L67">    private final CountDownLatch shutdownLatch = new CountDownLatch(1);</span>

    private RiakCluster(Builder builder)
<span class="fc" id="L70">    {</span>
<span class="fc" id="L71">        this.executionAttempts = builder.executionAttempts;</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">        this.queueOperations =  builder.operationQueueMaxDepth &gt; 0;</span>

<span class="fc bfc" id="L74" title="All 2 branches covered.">        if (null == builder.nodeManager)</span>
        {
<span class="fc" id="L76">            nodeManager = new DefaultNodeManager();</span>
        }
        else
        {
<span class="fc" id="L80">            this.nodeManager = builder.nodeManager;</span>
        }

<span class="fc bfc" id="L83" title="All 2 branches covered.">        if (builder.bootstrap != null)</span>
        {
<span class="fc" id="L85">            this.bootstrap = builder.bootstrap.clone();</span>
        }
        else
        {
<span class="fc" id="L89">            this.bootstrap = new Bootstrap()</span>
<span class="fc" id="L90">                .group(new NioEventLoopGroup())</span>
<span class="fc" id="L91">                .channel(NioSocketChannel.class);</span>
        }

<span class="pc bpc" id="L94" title="1 of 2 branches missed.">        if (builder.executor != null)</span>
        {
<span class="nc" id="L96">            executor = builder.executor;</span>
        }
        else
        {
            // Retry Task, Shutdown Task, (optional) Queue Task
<span class="fc bfc" id="L101" title="All 2 branches covered.">            Integer poolSize = this.queueOperations ? 3 : 2;</span>

            // We still need an executor if none was provided.
<span class="fc" id="L104">            executor = new ScheduledThreadPoolExecutor(poolSize);</span>
        }

<span class="fc" id="L107">        nodeList = new ArrayList&lt;&gt;(builder.riakNodes.size());</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">        for (RiakNode node : builder.riakNodes)</span>
        {
<span class="fc" id="L110">            node.setExecutor(executor);</span>
<span class="fc" id="L111">            node.setBootstrap(bootstrap);</span>
<span class="fc" id="L112">            node.addStateListener(nodeManager);</span>
<span class="fc" id="L113">            nodeList.add(node);</span>
<span class="fc" id="L114">        }</span>

<span class="fc bfc" id="L116" title="All 2 branches covered.">        if (this.queueOperations)</span>
        {
<span class="fc" id="L118">            this.operationQueue = new ConcurrentLinkedDeque&lt;&gt;();</span>
<span class="fc" id="L119">            this.operationQueuePermits = new RiakNode.Sync(builder.operationQueueMaxDepth);</span>

<span class="fc bfc" id="L121" title="All 2 branches covered.">            for (RiakNode node : nodeList)</span>
            {
<span class="fc" id="L123">                node.setBlockOnMaxConnections(false);</span>
<span class="fc" id="L124">            }</span>
        }
        else
        {
<span class="fc" id="L128">            this.operationQueuePermits = new RiakNode.Sync(0);</span>
<span class="fc" id="L129">            this.operationQueue = null;</span>
        }

        // Pass a *copy* of the list to the NodeManager
<span class="fc" id="L133">        nodeManager.init(new ArrayList&lt;&gt;(nodeList));</span>
<span class="fc" id="L134">        state = State.CREATED;</span>
<span class="fc" id="L135">    }</span>

    private void stateCheck(State... allowedStates)
    {
<span class="fc bfc" id="L139" title="All 2 branches covered.">        if (Arrays.binarySearch(allowedStates, state) &lt; 0)</span>
        {
<span class="fc" id="L141">            logger.debug(&quot;IllegalStateException; required: {} current: {} &quot;,</span>
<span class="fc" id="L142">                         Arrays.toString(allowedStates), state);</span>
<span class="fc" id="L143">            throw new IllegalStateException(&quot;required: &quot;</span>
<span class="fc" id="L144">                + Arrays.toString(allowedStates)</span>
                + &quot; current: &quot; + state );
        }
<span class="fc" id="L147">    }</span>

    public synchronized void start()
    {
<span class="fc" id="L151">        stateCheck(State.CREATED);</span>

        // Completely unneeded *right now* but operating on a copy
        // of the nodeList defensively prevents a deadlock occuring
        // if a callback were to try and modify the list.
<span class="fc bfc" id="L156" title="All 2 branches covered.">        for (RiakNode node : getNodes())</span>
        {
            try
            {
<span class="fc" id="L160">                node.start();</span>
            }
<span class="nc" id="L162">            catch (UnknownHostException e)</span>
            {
<span class="nc" id="L164">                logger.error(&quot;RiakCluster::start - Failed starting node: {}&quot;, e.getMessage());</span>
<span class="fc" id="L165">            }</span>
<span class="fc" id="L166">        }</span>

<span class="fc" id="L168">        retrierFuture = executor.schedule(new RetryTask(), 0, TimeUnit.SECONDS);</span>

<span class="fc bfc" id="L170" title="All 2 branches covered.">        if (this.queueOperations)</span>
        {
<span class="fc" id="L172">            queueDrainFuture = executor.schedule(new QueueDrainTask(), 0, TimeUnit.SECONDS);</span>
        }

<span class="fc" id="L175">        logger.info(&quot;RiakCluster is starting.&quot;);</span>
<span class="fc" id="L176">        state = State.RUNNING;</span>
<span class="fc" id="L177">    }</span>

    public synchronized Future&lt;Boolean&gt; shutdown()
    {
<span class="fc" id="L181">        stateCheck(State.RUNNING, State.QUEUING);</span>
<span class="fc" id="L182">        logger.info(&quot;RiakCluster is shutting down.&quot;);</span>
<span class="fc" id="L183">        state = State.SHUTTING_DOWN;</span>

        // Wait for all in-progress operations to drain
        // then shut down nodes.
<span class="fc" id="L187">        shutdownFuture = executor.scheduleWithFixedDelay(new ShutdownTask(),</span>
                                                         500, 500,
                                                         TimeUnit.MILLISECONDS);

<span class="fc" id="L191">        return new Future&lt;Boolean&gt;()</span>
<span class="fc" id="L192">        {</span>
            @Override
            public boolean cancel(boolean mayInterruptIfRunning)
            {
<span class="nc" id="L196">                return false;</span>
            }
            @Override
            public Boolean get() throws InterruptedException
            {
<span class="fc" id="L201">                shutdownLatch.await();</span>
<span class="fc" id="L202">                return true;</span>
            }
            @Override
            public Boolean get(long timeout, TimeUnit unit) throws InterruptedException
            {
<span class="nc" id="L207">                return shutdownLatch.await(timeout, unit);</span>
            }
            @Override
            public boolean isCancelled()
            {
<span class="nc" id="L212">                return false;</span>
            }
            @Override
            public boolean isDone()
            {
<span class="nc bnc" id="L217" title="All 2 branches missed.">                return shutdownLatch.getCount() &lt;= 0;</span>
            }
        };
    }

    public &lt;V,S&gt; RiakFuture&lt;V,S&gt; execute(FutureOperation&lt;V, ?, S&gt; operation)
    {
<span class="fc" id="L224">        return executeFutureOperation(operation);</span>
    }

    public &lt;V, S&gt; StreamingRiakFuture&lt;V,S&gt; execute(PBStreamingFutureOperation&lt;V, ?, S&gt; operation)
    {
<span class="nc" id="L229">        execute((FutureOperation&lt;V,?,S&gt;)operation);</span>
        // N.B. Currently the operation and future are one in the same,
        // so we can just return the operation to accomplish our
        // StreamingRiakFuture return type contract.
<span class="nc" id="L233">        return operation;</span>
    }

    private &lt;V, S&gt; RiakFuture&lt;V, S&gt; executeFutureOperation(FutureOperation&lt;V, ?, S&gt; operation)
    {
<span class="fc" id="L238">        stateCheck(State.RUNNING, State.QUEUING);</span>
<span class="fc" id="L239">        operation.setRetrier(this, executionAttempts);</span>
<span class="fc" id="L240">        inFlightCount.incrementAndGet();</span>

<span class="fc" id="L242">        boolean gotConnection = false;</span>

        // Avoid queue if we're not using it, or it's currently empty
<span class="fc bfc" id="L245" title="All 2 branches covered.">        if (notQueuingOrQueueIsEmpty())</span>
        {
<span class="fc" id="L247">            gotConnection = this.execute(operation, null);</span>
        }

<span class="fc bfc" id="L250" title="All 2 branches covered.">        if (!gotConnection) // Operation didn't run</span>
        {
            // Queue it up, run next from queue
<span class="fc bfc" id="L253" title="All 2 branches covered.">            if (this.queueOperations)</span>
            {
<span class="fc" id="L255">                executeWithQueueStrategy(operation);</span>
            }
            else // Out of connections, retrier will pick it up later.
            {
<span class="fc" id="L259">                operation.setException(new NoNodesAvailableException());</span>
            }
        }

<span class="fc" id="L263">        return operation;</span>
    }

    private boolean notQueuingOrQueueIsEmpty()
    {
<span class="fc bfc" id="L268" title="All 4 branches covered.">        return !this.queueOperations || this.operationQueue.size() == 0;</span>
    }

    private void executeWithQueueStrategy(FutureOperation operation)
    {
<span class="fc bfc" id="L273" title="All 2 branches covered.">        if (!operationQueuePermits.tryAcquire())</span>
        {
<span class="fc" id="L275">            logger.warn(&quot;Can't execute operation {}, no connections available, and Operation Queue at Max Depth&quot;,</span>
<span class="fc" id="L276">                        System.identityHashCode(operation));</span>
<span class="fc" id="L277">            operation.setRetrier(this, 1);</span>
<span class="fc" id="L278">            operation.setException(new NoNodesAvailableException(&quot;No Nodes Available, and Operation Queue at Max Depth&quot;));</span>
<span class="fc" id="L279">            return;</span>
        }

<span class="fc" id="L282">        operationQueue.offer(operation);</span>
<span class="fc" id="L283">        verifyQueueStatus();</span>

        // Get next queued operation
<span class="fc" id="L286">        FutureOperation operationNext = operationQueue.poll();</span>
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">        if (operationNext == null)</span>
        {
<span class="nc" id="L289">            return;</span>
        }

<span class="fc" id="L292">        executeWithRequeueOnNoConnection(operationNext);</span>
<span class="fc" id="L293">    }</span>

    private boolean executeWithRequeueOnNoConnection(FutureOperation operation)
    {
<span class="fc" id="L297">        logger.debug(&quot;Queued operation {} attempting to be executed.&quot;, System.identityHashCode(operation));</span>
        // Attempt to run
<span class="fc" id="L299">        boolean gotConnection = this.execute(operation, null);</span>

        // If we can't get a connection, put it back at the beginning of the queue
<span class="fc bfc" id="L302" title="All 2 branches covered.">        if (!gotConnection)</span>
        {
<span class="fc" id="L304">            logger.debug(&quot;Queued operation {} wasn't executed, no connection available, requeuing operation.&quot;,</span>
<span class="fc" id="L305">                         System.identityHashCode(operation));</span>
<span class="fc" id="L306">            operationQueue.offerFirst(operation);</span>
        }
        else
        {
<span class="fc" id="L310">            operationQueuePermits.release();</span>
        }

<span class="fc" id="L313">        verifyQueueStatus();</span>

<span class="fc" id="L315">        return gotConnection;</span>
    }

    private synchronized void verifyQueueStatus()
    {
<span class="fc" id="L320">        Integer queueSize = operationQueuePermits.getMaxPermits() - operationQueuePermits.availablePermits();</span>

<span class="fc bfc" id="L322" title="All 4 branches covered.">        if (queueSize &gt; 0 &amp;&amp; state == State.RUNNING)</span>
        {
<span class="fc" id="L324">            state = State.QUEUING;</span>
<span class="fc" id="L325">            logger.debug(&quot;RiakCluster state change: Now Queuing operations.&quot;);</span>
        }
<span class="pc bpc" id="L327" title="3 of 6 branches missed.">        else if (queueSize == 0 &amp;&amp; (state == State.QUEUING || state == State.SHUTTING_DOWN))</span>
        {
<span class="fc" id="L329">            logger.debug(&quot;RiakCluster state change: Cleared operation queue.&quot;);</span>
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">            if (state == State.QUEUING)</span>
            {
<span class="fc" id="L332">                state = State.RUNNING;</span>
            }
        }
<span class="fc" id="L335">    }</span>

    private boolean execute(FutureOperation operation, RiakNode previousNode)
    {
<span class="fc" id="L339">        return nodeManager.executeOnNode(operation, previousNode);</span>
    }

    /**
     * Adds a {@link RiakNode} to this cluster.
     * The node can not have been started nor have its Bootstrap or Executor
     * asSet.
     * The node will be started as part of this process.
     * @param node the RiakNode to add
     * @throws java.net.UnknownHostException if the RiakNode's hostname cannot be resolved
     * @throws IllegalArgumentException if the node's Bootstrap or Executor are already asSet.
     */
    public void addNode(RiakNode node) throws UnknownHostException
    {
<span class="fc" id="L353">        stateCheck(State.CREATED, State.RUNNING, State.QUEUING);</span>
<span class="fc" id="L354">        node.setExecutor(executor);</span>
<span class="fc" id="L355">        node.setBootstrap(bootstrap);</span>

        try
        {
<span class="fc" id="L359">            nodeListLock.writeLock().lock();</span>
<span class="fc" id="L360">            nodeList.add(node);</span>
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">            for (NodeStateListener listener : stateListeners)</span>
            {
<span class="nc" id="L363">                node.addStateListener(listener);</span>
<span class="nc" id="L364">            }</span>
        }
        finally
        {
<span class="pc" id="L368">            nodeListLock.writeLock().unlock();</span>
<span class="fc" id="L369">        }</span>

<span class="fc" id="L371">        node.start();</span>

<span class="fc" id="L373">        nodeManager.addNode(node);</span>
<span class="fc" id="L374">    }</span>

    /**
     * Removes the provided node from the cluster.
     * @param node
     * @return true if the node was in the cluster, false otherwise.
     */
    public boolean removeNode(RiakNode node)
    {
<span class="fc" id="L383">        stateCheck(State.CREATED, State.RUNNING, State.QUEUING);</span>
<span class="fc" id="L384">        boolean removed = false;</span>
        try
        {
<span class="fc" id="L387">            nodeListLock.writeLock().lock();</span>
<span class="fc" id="L388">            removed = nodeList.remove(node);</span>
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">            for (NodeStateListener listener : stateListeners)</span>
            {
<span class="nc" id="L391">                node.removeStateListener(listener);</span>
<span class="nc" id="L392">            }</span>
        }
        finally
        {
<span class="pc" id="L396">            nodeListLock.writeLock().unlock();</span>
<span class="fc" id="L397">        }</span>
<span class="fc" id="L398">        nodeManager.removeNode(node);</span>
<span class="fc" id="L399">        return removed;</span>
    }

    /**
     * Returns a copy of the list of nodes in this cluster.
     * @return A copy of the list of RiakNodes
     */
    public List&lt;RiakNode&gt; getNodes()
    {
<span class="fc" id="L408">        stateCheck(State.CREATED, State.RUNNING, State.SHUTTING_DOWN, State.QUEUING);</span>
        try
        {
<span class="fc" id="L411">            nodeListLock.readLock().lock();</span>
<span class="fc" id="L412">            return new ArrayList&lt;&gt;(nodeList);</span>
        }
        finally
        {
<span class="pc" id="L416">            nodeListLock.readLock().unlock();</span>
        }
    }

    int inFlightCount()
    {
<span class="fc" id="L422">        return inFlightCount.get();</span>
    }

    @Override
    public void nodeStateChanged(RiakNode node, RiakNode.State state)
    {
        // We only listen for state changes after telling all the nodes
        // to shutdown.
<span class="fc bfc" id="L430" title="All 2 branches covered.">        if (state == RiakNode.State.SHUTDOWN)</span>
        {
<span class="fc" id="L432">            logger.debug(&quot;Node state changed to shutdown; {}:{}&quot;, node.getRemoteAddress(), node.getPort());</span>
            try
            {
<span class="fc" id="L435">                nodeListLock.writeLock().lock();</span>
<span class="fc" id="L436">                nodeList.remove(node);</span>
<span class="fc" id="L437">                logger.debug(&quot;Active nodes remaining: {}&quot;, nodeList.size());</span>

<span class="fc bfc" id="L439" title="All 2 branches covered.">                if (nodeList.isEmpty())</span>
                {
<span class="fc" id="L441">                    this.state = State.SHUTDOWN;</span>
<span class="fc" id="L442">                    executor.shutdown();</span>
<span class="fc" id="L443">                    bootstrap.config().group().shutdownGracefully();</span>
<span class="fc" id="L444">                    logger.debug(&quot;RiakCluster shut down bootstrap&quot;);</span>
<span class="fc" id="L445">                    logger.info(&quot;RiakCluster has shut down&quot;);</span>
<span class="fc" id="L446">                    shutdownLatch.countDown();</span>
                }
            }
            finally
            {
<span class="pc" id="L451">                nodeListLock.writeLock().unlock();</span>
<span class="fc" id="L452">            }</span>
        }
<span class="fc" id="L454">    }</span>

    @Override
    public void operationFailed(FutureOperation operation, int remainingRetries)
    {
<span class="fc" id="L459">        logger.debug(&quot;operation {} failed; remaining retries: {}&quot;, System.identityHashCode(operation), remainingRetries);</span>
<span class="fc bfc" id="L460" title="All 2 branches covered.">        if (remainingRetries &gt; 0)</span>
        {
<span class="fc" id="L462">            retryQueue.add(operation);</span>
        }
        else
        {
<span class="fc" id="L466">            inFlightCount.decrementAndGet();</span>
        }
<span class="fc" id="L468">    }</span>

    @Override
    public void operationComplete(FutureOperation operation, int remainingRetries)
    {
<span class="fc" id="L473">        inFlightCount.decrementAndGet();</span>
<span class="fc" id="L474">        logger.debug(&quot;operation {} complete; remaining retries: {}&quot;, System.identityHashCode(operation), remainingRetries);</span>
<span class="fc" id="L475">    }</span>

    private void retryOperation() throws InterruptedException
    {
<span class="fc" id="L479">        FutureOperation operation = retryQueue.take();</span>

<span class="fc" id="L481">        Boolean gotConnection = execute(operation, operation.getLastNode());</span>

<span class="fc bfc" id="L483" title="All 2 branches covered.">        if (!gotConnection)</span>
        {
<span class="fc" id="L485">            operation.setException(new NoNodesAvailableException());</span>
        }
<span class="fc" id="L487">    }</span>

    private void queueDrainOperation() throws InterruptedException
    {
<span class="fc" id="L491">        logger.debug(&quot;QueueDrainer - Polling for queued operations.&quot;);</span>
<span class="fc" id="L492">        FutureOperation operation = operationQueue.poll();</span>
<span class="fc bfc" id="L493" title="All 2 branches covered.">        if (operation == null)</span>
        {
<span class="fc" id="L495">            logger.debug(&quot;QueueDrainer - No queued operation available, sleeping.&quot;);</span>
<span class="fc" id="L496">            Thread.sleep(50);</span>
<span class="fc" id="L497">            return;</span>
        }

<span class="fc" id="L500">        boolean connectionSuccess = executeWithRequeueOnNoConnection(operation);</span>

        // If we didn't get a connection here, then we are thrashing on connections
        // Sleep for a bit so we don't spinwait our CPUs to death
<span class="fc bfc" id="L504" title="All 2 branches covered.">        if (!connectionSuccess)</span>
        {
<span class="fc" id="L506">            logger.debug(&quot;QueueDrainer - Pulled queued operation {}, but no connection available, sleeping.&quot;,</span>
<span class="fc" id="L507">                         System.identityHashCode(operation));</span>

            // TODO: should this timeout be configurable, or based on an
            // average command execution time?
<span class="fc" id="L511">            Thread.sleep(50);</span>
        }
<span class="fc" id="L513">    }</span>

    /**
     * Register a NodeStateListener.
     * &lt;p&gt;
     * Any state change by any of the nodes in the cluster will be sent to
     * the registered NodeStateListener.
     * &lt;/p&gt;
     * &lt;p&gt;When registering, the current state of all the nodes is sent to the
     * listener.
     * &lt;/p&gt;
     * @param listener The NodeStateListener to register.
     */
    public void registerNodeStateListener(NodeStateListener listener)
    {
<span class="fc" id="L528">        stateCheck(State.CREATED, State.RUNNING, State.SHUTTING_DOWN, State.QUEUING);</span>
        try
        {
<span class="fc" id="L531">            stateListeners.add(listener);</span>
<span class="fc" id="L532">            nodeListLock.readLock().lock();</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">            for (RiakNode node : nodeList)</span>
            {
<span class="fc" id="L535">                node.addStateListener(listener);</span>
<span class="fc" id="L536">                listener.nodeStateChanged(node, node.getNodeState());</span>
<span class="fc" id="L537">            }</span>
        }
        finally
        {
<span class="pc" id="L541">            nodeListLock.readLock().unlock();</span>
<span class="fc" id="L542">        }</span>
<span class="fc" id="L543">    }</span>

    /**
     * Remove a NodeStateListener.
     * &lt;p&gt;
     * The supplied NodeStateListener will be unregistered and no longer
     * receive state updates.
     * &lt;/p&gt;
     * @param listener The NodeStateListener to unregister.
     */
    public void removeNodeStateListener(NodeStateListener listener)
    {
<span class="nc" id="L555">        stateCheck(State.CREATED, State.RUNNING, State.SHUTTING_DOWN, State.QUEUING);</span>
        try
        {
<span class="nc" id="L558">            stateListeners.remove(listener);</span>
<span class="nc" id="L559">            nodeListLock.readLock().lock();</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">            for (RiakNode node : nodeList)</span>
            {
<span class="nc" id="L562">                node.removeStateListener(listener);</span>
<span class="nc" id="L563">            }</span>
        }
        finally
        {
<span class="nc" id="L567">            nodeListLock.readLock().unlock();</span>
<span class="nc" id="L568">        }</span>
<span class="nc" id="L569">    }</span>

<span class="fc" id="L571">    private class RetryTask implements Runnable</span>
    {
        @Override
        public void run()
        {
<span class="pc bpc" id="L576" title="1 of 2 branches missed.">            while (!Thread.interrupted())</span>
            {
                try
                {
<span class="fc" id="L580">                    retryOperation();</span>
                }
<span class="fc" id="L582">                catch (InterruptedException ex)</span>
                {
<span class="fc" id="L584">                    break;</span>
<span class="fc" id="L585">                }</span>
            }

<span class="fc" id="L588">            logger.info(&quot;Retrier shutting down.&quot;);</span>
<span class="fc" id="L589">        }</span>
    }

<span class="fc" id="L592">    private class QueueDrainTask implements Runnable</span>
    {
        @Override
        public void run()
        {
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">            while (!Thread.interrupted())</span>
            {
                try
                {
<span class="fc" id="L601">                    queueDrainOperation();</span>
                }
<span class="fc" id="L603">                catch (InterruptedException ex)</span>
                {
<span class="fc" id="L605">                    break;</span>
<span class="fc" id="L606">                }</span>
            }

<span class="fc" id="L609">            logger.info(&quot;Queue Worker shutting down.&quot;);</span>
<span class="fc" id="L610">        }</span>
    }

<span class="fc" id="L613">    private class ShutdownTask implements Runnable</span>
    {
        @Override
        public void run()
        {
<span class="pc bpc" id="L618" title="1 of 2 branches missed.">            if (inFlightCount.get() == 0)</span>
            {
<span class="fc" id="L620">                logger.info(&quot;All operations have completed&quot;);</span>

<span class="fc" id="L622">                retrierFuture.cancel(true);</span>

<span class="fc bfc" id="L624" title="All 2 branches covered.">                if (queueOperations)</span>
                {
<span class="fc" id="L626">                    queueDrainFuture.cancel(true);</span>
                }

                // Copying the list avoids any potential deadlocks on the callbacks.
<span class="fc bfc" id="L630" title="All 2 branches covered.">                for (RiakNode node : getNodes())</span>
                {
<span class="fc" id="L632">                    node.addStateListener(RiakCluster.this);</span>
<span class="fc" id="L633">                    logger.debug(&quot;calling shutdown on node {}:{}&quot;, node.getRemoteAddress(), node.getPort());</span>
<span class="fc" id="L634">                    node.shutdown();</span>
<span class="fc" id="L635">                }</span>

<span class="fc" id="L637">                shutdownFuture.cancel(false);</span>
            }
<span class="fc" id="L639">        }</span>
    }

        public static Builder builder(List&lt;RiakNode&gt; nodes)
        {
<span class="nc" id="L644">            return new Builder(nodes);</span>
        }

        public static Builder builder(RiakNode node)
        {
<span class="fc" id="L649">            return new Builder(node);</span>
        }

    /**
     * Cleans up any Thread-Local variables after shutdown.
     * This operation is useful when you are in a container environment, and you
     * do not want to leave the thread local variables in the threads you do not manage.
     * Call this method when your application is being unloaded from the container, &lt;b&gt;after&lt;/b&gt;
     * all {@link RiakNode}, {@link RiakCluster}, and {@link com.basho.riak.client.api.RiakClient}
     * objects are in the shutdown state.
     */
    public synchronized void cleanup()
    {
<span class="fc" id="L662">        stateCheck(State.SHUTDOWN);</span>
<span class="fc" id="L663">        io.netty.util.concurrent.FastThreadLocal.removeAll();</span>
<span class="fc" id="L664">        io.netty.util.concurrent.FastThreadLocal.destroy();</span>
<span class="fc" id="L665">    }</span>

    /**
     * Builder used to create {@link RiakCluster} instances.
     */
    public static class Builder
    {
        public final static int DEFAULT_EXECUTION_ATTEMPTS = 3;
        public final static int DEFAULT_OPERATION_QUEUE_DEPTH = 0;

        private final List&lt;RiakNode&gt; riakNodes;

<span class="pc" id="L677">        private int executionAttempts = DEFAULT_EXECUTION_ATTEMPTS;</span>
<span class="pc" id="L678">        private int operationQueueMaxDepth = DEFAULT_OPERATION_QUEUE_DEPTH;</span>

        private NodeManager nodeManager;
        private ScheduledExecutorService executor;
        private Bootstrap bootstrap;

        /**
         * Instantiate a Builder containing the supplied {@link RiakNode}s
         * @param riakNodes - a List of unstarted RiakNode objects
         */
        public Builder(List&lt;RiakNode&gt; riakNodes)
<span class="fc" id="L689">        {</span>
<span class="fc" id="L690">            this.riakNodes = new ArrayList&lt;&gt;(riakNodes);</span>
<span class="fc" id="L691">        }</span>

        /**
         * Instantiate a Builder containing the {@link RiakNode}s that will be build by using provided builder.
         * The RiakNode.Builder is used for setting common properties among the nodes.
         * @since 2.0.3
         * @see com.basho.riak.client.core.RiakNode.Builder#buildNodes(RiakNode.Builder, List)
         */
        public Builder(RiakNode.Builder nodeBuilder, List&lt;String&gt; remoteAddresses) throws UnknownHostException
<span class="fc" id="L700">        {</span>
<span class="fc" id="L701">            riakNodes = RiakNode.Builder.buildNodes(nodeBuilder, remoteAddresses );</span>
<span class="fc" id="L702">        }</span>

        /**
         * Instantiate a Builder containing the {@link RiakNode}s that will be build by using provided builder.
         * The RiakNode.Builder is used for setting common properties among the nodes.
         * @since 2.0.6
         * @see com.basho.riak.client.core.RiakNode.Builder#buildNodes(Collection, RiakNode.Builder)
         */
        public Builder(Collection&lt;HostAndPort&gt; remoteHosts, RiakNode.Builder nodeBuilder) throws UnknownHostException
<span class="nc" id="L711">        {</span>
<span class="nc" id="L712">            riakNodes = RiakNode.Builder.buildNodes(remoteHosts, nodeBuilder);</span>
<span class="nc" id="L713">        }</span>

        /**
         * Instantiate a Builder containing the {@link RiakNode}s that will be build by using provided builder.
         * The RiakNode.Builder is used for setting common properties among the nodes.
         * @since 2.0.3
         * @see com.basho.riak.client.core.RiakNode.Builder#buildNodes(RiakNode.Builder, String...)
         */
        public Builder(RiakNode.Builder nodeBuilder, String... remoteAddresses) throws UnknownHostException
<span class="fc" id="L722">        {</span>
<span class="fc" id="L723">            riakNodes = RiakNode.Builder.buildNodes(nodeBuilder, remoteAddresses );</span>
<span class="fc" id="L724">        }</span>

        /**
         * Instantiate a Builder containing a single {@link RiakNode}
         * @param node
         */
        public Builder(RiakNode node)
<span class="fc" id="L731">        {</span>
<span class="fc" id="L732">            this.riakNodes = new ArrayList&lt;&gt;(1);</span>
<span class="fc" id="L733">            this.riakNodes.add(node);</span>
<span class="fc" id="L734">        }</span>

        /**
         * Sets the number of times the {@link RiakCluster} will attempt an
         * operation before returning it as failed.
         * @param numberOfAttempts
         * @return this
         */
        public Builder withExecutionAttempts(int numberOfAttempts)
        {
<span class="fc" id="L744">            this.executionAttempts = numberOfAttempts;</span>
<span class="fc" id="L745">            return this;</span>
        }

        /**
         * Sets the {@link NodeManager} for this {@link RiakCluster}
         *
         * If none is provided the {@link DefaultNodeManager} will be used
         * @param nodeManager
         * @return this
         */
        public Builder withNodeManager(NodeManager nodeManager)
        {
<span class="fc" id="L757">            this.nodeManager = nodeManager;</span>
<span class="fc" id="L758">            return this;</span>
        }

        /**
         * Sets the Threadpool for this cluster.
         *
         * This threadpool is passed down to the {@link RiakNode}s.
         * At the very least it needs to have
         * two threads available. It is not necessary to supply your own as the
         * {@link RiakCluster} will instantiate one upon construction if this is
         * not asSet.
         * @param executor
         * @return this
         */
        public Builder withExecutor(ScheduledExecutorService executor)
        {
<span class="nc" id="L774">            this.executor = executor;</span>
<span class="nc" id="L775">            return this;</span>
        }

        /**
         * The Netty {@link Bootstrap} this cluster will use.
         *
         * This Bootstrap is passed down to the {@link RiakNode}s.
         * It is not necessary to supply your
         * own as the {@link RiakCluster} will instantiate one upon construction
         * if this is not asSet.
         * @param bootstrap
         * @return this
         */
        public Builder withBootstrap(Bootstrap bootstrap)
        {
<span class="fc" id="L790">            this.bootstrap = bootstrap;</span>
<span class="fc" id="L791">            return this;</span>
        }

        /**
         * Set the maximum number of operations to queue.
         * A value of 0 disables the command queue.
         * &lt;b&gt;Setting this will override any of this clusters @{link RiakNode}s blockOnMaxConnection settings.&lt;/b&gt;
         * &lt;p&gt;
         *     Please note that while using the Operation Queue, operations may be executed out of the order
         * that they were added in.
         * &lt;/p&gt;
         *
         * @param operationQueueMaxDepth - maximum number of operations to queue if all connections are busy
         * @return this
         * @see #DEFAULT_OPERATION_QUEUE_DEPTH
         */
        public Builder withOperationQueueMaxDepth(int operationQueueMaxDepth)
        {
<span class="fc" id="L809">            this.operationQueueMaxDepth = operationQueueMaxDepth;</span>
<span class="fc" id="L810">            return this;</span>
        }

        /**
         * Instantiates the {@link RiakCluster}
         * @return a new RiakCluster
         */
        public RiakCluster build()
        {
<span class="fc" id="L819">            return new RiakCluster(this);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>