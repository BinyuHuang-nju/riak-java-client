<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RiakNode.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Riak Client for Java</a> &gt; <a href="index.source.html" class="el_package">com.basho.riak.client.core</a> &gt; <span class="el_source">RiakNode.java</span></div><h1>RiakNode.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2013 Basho Technologies, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.basho.riak.client.core;

import com.basho.riak.client.core.netty.*;
import com.basho.riak.client.core.util.Constants;
import com.basho.riak.client.core.util.HostAndPort;
import io.netty.bootstrap.Bootstrap;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelOption;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.util.concurrent.BlockingOperationException;
import io.netty.util.concurrent.DefaultPromise;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLEngine;
import javax.net.ssl.TrustManagerFactory;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.UnknownHostException;
import java.security.KeyStore;
import java.security.Security;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicLong;

/**
 * @author Brian Roach &lt;roach at basho dot com&gt;
 * @author Sergey Galkin &lt;srggal at gmail dot com&gt;
 * @author Alex Moore &lt;amoore at basho dot com&gt;
 * @since 2.0
 */
public class RiakNode implements RiakResponseListener
{
<span class="pc" id="L54">    public enum State</span>
    {
<span class="fc" id="L56">        CREATED, RUNNING, HEALTH_CHECKING, SHUTTING_DOWN, SHUTDOWN;</span>
    }

<span class="fc" id="L59">    private final Logger logger = LoggerFactory.getLogger(RiakNode.class);</span>

<span class="fc" id="L61">    private final LinkedBlockingDeque&lt;ChannelWithIdleTime&gt; available = new LinkedBlockingDeque&lt;&gt;();</span>
<span class="fc" id="L62">    private final ConcurrentLinkedQueue&lt;ChannelWithIdleTime&gt; recentlyClosed = new ConcurrentLinkedQueue&lt;&gt;();</span>
<span class="fc" id="L63">    private final List&lt;NodeStateListener&gt; stateListeners =</span>
<span class="fc" id="L64">        Collections.synchronizedList(new LinkedList&lt;NodeStateListener&gt;());</span>
<span class="fc" id="L65">    private final Map&lt;Channel, FutureOperation&gt; inProgressMap = new ConcurrentHashMap&lt;&gt;();</span>

    private final Sync permits;
    private final String remoteAddress;
    private final int port;
    private final String username;
    private final String password;
    private final KeyStore trustStore;
    private final KeyStore keyStore;
    private final String keyPassword;
<span class="fc" id="L75">    private final AtomicLong consecutiveFailedOperations = new AtomicLong(0);</span>
<span class="fc" id="L76">    private final AtomicLong consecutiveFailedConnectionAttempts = new AtomicLong(0);</span>

    private volatile Bootstrap bootstrap;
    private volatile boolean ownsBootstrap;
    private volatile ScheduledExecutorService executor;
    private volatile boolean ownsExecutor;
    private volatile State state;
    private volatile ScheduledFuture&lt;?&gt; idleReaperFuture;
    private volatile ScheduledFuture&lt;?&gt; healthMonitorFuture;
    private volatile int minConnections;
    private volatile long idleTimeoutInNanos;
    private volatile int connectionTimeout;
    private volatile boolean blockOnMaxConnections;

    private HealthCheckFactory healthCheckFactory;

<span class="fc" id="L92">    private final ChannelFutureListener writeListener =</span>
        new ChannelFutureListener()
<span class="fc" id="L94">        {</span>
            @Override
            public void operationComplete(ChannelFuture future) throws Exception
            {
                // If there's a write failure, we yank the operation, close
                // the channel, and set the exception. Returning the closed
                // channel to the pool discards it and records a disconnect
                // for the health check.
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">                if (!future.isSuccess())</span>
                {
<span class="nc" id="L104">                    logger.error(&quot;Write failed on RiakNode {}:{} id: {}; cause: {}&quot;,</span>
<span class="nc" id="L105">                                remoteAddress, port, future.channel().hashCode(),</span>
<span class="nc" id="L106">                                future.cause());</span>
<span class="nc" id="L107">                    FutureOperation inProgress = inProgressMap.remove(future.channel());</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">                    if (inProgress != null)</span>
                    {
<span class="nc" id="L110">                        future.channel().close();</span>
<span class="nc" id="L111">                        returnConnection(future.channel()); // to release permit</span>
<span class="nc" id="L112">                        recentlyClosed.add(new ChannelWithIdleTime(future.channel()));</span>
<span class="nc" id="L113">                        inProgress.setException(future.cause());</span>
                    }
<span class="nc" id="L115">                }</span>
                else
                {
                    // On a successful write we add the in-progress close listener
                    // and let it handle a disco during an op.
<span class="fc" id="L120">                    future.channel().closeFuture().addListener(inProgressCloseListener);</span>
                }
<span class="fc" id="L122">            }</span>
        };

<span class="fc" id="L125">    private final ChannelFutureListener inAvailableCloseListener =</span>
        new ChannelFutureListener()
<span class="fc" id="L127">        {</span>
            @Override
            public void operationComplete(ChannelFuture future) throws Exception
            {
                // Rather than having to do an O(n) search here, we just leave
                // the channel in available. Because it's closed it'll be discarded
                // the next time it's pulled from the pool.
                // We record the disco for the health check.
<span class="fc" id="L135">                recentlyClosed.add(new ChannelWithIdleTime(future.channel()));</span>
<span class="fc" id="L136">                logger.info(&quot;Available channel closed; id:{} {}:{}&quot;,</span>
<span class="fc" id="L137">                             future.channel().hashCode(), remoteAddress, port);</span>
<span class="fc" id="L138">            }</span>
        };

<span class="fc" id="L141">    private final ChannelFutureListener inProgressCloseListener =</span>
        new ChannelFutureListener()
<span class="fc" id="L143">        {</span>
            @Override
            public void operationComplete(ChannelFuture future) throws Exception
            {
<span class="fc" id="L147">                FutureOperation inProgress = inProgressMap.remove(future.channel());</span>
<span class="fc" id="L148">                logger.error(&quot;Channel closed while operation in progress; id:{} {}:{}&quot;,</span>
<span class="fc" id="L149">                             future.channel().hashCode(), remoteAddress, port);</span>
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">                if (inProgress != null)</span>
                {
<span class="fc" id="L152">                    returnConnection(future.channel()); // to release permit</span>
<span class="fc" id="L153">                    recentlyClosed.add(new ChannelWithIdleTime(future.channel()));</span>

                    // Netty seems to not bother telling you *why* the connection
                    // was closed.
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">                    if (future.cause() != null)</span>
                    {
<span class="nc" id="L159">                        inProgress.setException(future.cause());</span>
                    }
                    else
                    {
<span class="fc" id="L163">                        inProgress.setException(new Exception(&quot;Connection closed unexpectantly&quot;));</span>
                    }
                }
<span class="fc" id="L166">            }</span>
        };

<span class="fc" id="L169">    private final CountDownLatch shutdownLatch = new CountDownLatch(1);</span>

    private RiakNode(Builder builder)
<span class="fc" id="L172">    {</span>
<span class="fc" id="L173">        this.executor = builder.executor;</span>
<span class="fc" id="L174">        this.connectionTimeout = builder.connectionTimeout;</span>
<span class="fc" id="L175">        this.idleTimeoutInNanos = TimeUnit.NANOSECONDS.convert(builder.idleTimeout, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L176">        this.minConnections = builder.minConnections;</span>
<span class="fc" id="L177">        this.port = builder.port;</span>
<span class="fc" id="L178">        this.remoteAddress = builder.remoteAddress;</span>
<span class="fc" id="L179">        this.blockOnMaxConnections = builder.blockOnMaxConnections;</span>
<span class="fc" id="L180">        this.username = builder.username;</span>
<span class="fc" id="L181">        this.password = builder.password;</span>
<span class="fc" id="L182">        this.trustStore = builder.trustStore;</span>
<span class="fc" id="L183">        this.keyStore = builder.keyStore;</span>
<span class="fc" id="L184">        this.keyPassword = builder.keyPassword;</span>
<span class="fc" id="L185">        this.healthCheckFactory = builder.healthCheckFactory;</span>

<span class="fc bfc" id="L187" title="All 2 branches covered.">        if (builder.bootstrap != null)</span>
        {
<span class="fc" id="L189">            this.bootstrap = builder.bootstrap.clone();</span>
        }

<span class="fc bfc" id="L192" title="All 2 branches covered.">        if (builder.maxConnections &lt; 1)</span>
        {
<span class="fc" id="L194">            permits = new Sync(Integer.MAX_VALUE);</span>
        }
        else
        {
<span class="fc" id="L198">            permits = new Sync(builder.maxConnections);</span>
        }

<span class="fc" id="L201">        checkNetworkAddressCacheSettings();</span>

<span class="fc" id="L203">        this.state = State.CREATED;</span>
<span class="fc" id="L204">    }</span>

    private void stateCheck(State... allowedStates)
    {
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">        if (Arrays.binarySearch(allowedStates, state) &lt; 0)</span>
        {
<span class="nc" id="L210">            logger.debug(&quot;IllegalStateException; RiakNode: {}:{} required: {} current: {} &quot;,</span>
<span class="nc" id="L211">                remoteAddress, port, Arrays.toString(allowedStates), state);</span>
<span class="nc" id="L212">            throw new IllegalStateException(&quot;required: &quot;</span>
<span class="nc" id="L213">                + Arrays.toString(allowedStates)</span>
                + &quot; current: &quot; + state);
        }
<span class="fc" id="L216">    }</span>

    /**
     * exposed for testing only
     *
     * @return number of inprogress tasks
     */
    int getNumInProgress()
    {
<span class="fc" id="L225">        return inProgressMap.size();</span>
    }

    public synchronized RiakNode start() throws UnknownHostException
    {
<span class="fc" id="L230">        stateCheck(State.CREATED);</span>

<span class="fc bfc" id="L232" title="All 2 branches covered.">        if (executor == null)</span>
        {
<span class="fc" id="L234">            executor = Executors.newSingleThreadScheduledExecutor();</span>
<span class="fc" id="L235">            ownsExecutor = true;</span>
        }

<span class="fc bfc" id="L238" title="All 2 branches covered.">        if (bootstrap == null)</span>
        {
<span class="fc" id="L240">            bootstrap = new Bootstrap()</span>
<span class="fc" id="L241">                .group(new NioEventLoopGroup())</span>
<span class="fc" id="L242">                .channel(NioSocketChannel.class);</span>
<span class="fc" id="L243">            ownsBootstrap = true;</span>
        }

<span class="fc" id="L246">        bootstrap.handler(new RiakChannelInitializer(this));</span>

<span class="fc" id="L248">        refreshBootstrapRemoteAddress();</span>

<span class="fc bfc" id="L250" title="All 2 branches covered.">        if (connectionTimeout &gt; 0)</span>
        {
<span class="fc" id="L252">            bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, connectionTimeout);</span>
        }

<span class="pc bpc" id="L255" title="1 of 2 branches missed.">        if (minConnections &gt; 0)</span>
        {
<span class="fc" id="L257">            List&lt;Channel&gt; minChannels = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">            for (int i = 0; i &lt; minConnections; i++)</span>
            {
                Channel channel;
                try
                {
<span class="fc" id="L263">                    channel = doGetConnection(false);</span>
<span class="fc" id="L264">                    minChannels.add(channel);</span>
                }
<span class="fc" id="L266">                catch (ConnectionFailedException ex)</span>
                {
                    // no-op, we don't care right now
<span class="fc" id="L269">                }</span>
            }

<span class="fc bfc" id="L272" title="All 2 branches covered.">            for (Channel c : minChannels)</span>
            {
<span class="fc" id="L274">                available.offerFirst(new ChannelWithIdleTime(c));</span>
<span class="fc" id="L275">                c.closeFuture().addListener(inAvailableCloseListener);</span>
<span class="fc" id="L276">            }</span>
        }

<span class="fc" id="L279">        idleReaperFuture = executor.scheduleWithFixedDelay(new IdleReaper(), 1, 5, TimeUnit.SECONDS);</span>
<span class="fc" id="L280">        healthMonitorFuture = executor.scheduleWithFixedDelay(new HealthMonitorTask(), 1000, 1000, TimeUnit.MILLISECONDS);</span>

<span class="fc" id="L282">        state = State.RUNNING;</span>
<span class="fc" id="L283">        logger.info(&quot;RiakNode started; {}:{}&quot;, remoteAddress, port);</span>
<span class="fc" id="L284">        notifyStateListeners();</span>
<span class="fc" id="L285">        return this;</span>
    }

    private void refreshBootstrapRemoteAddress() throws UnknownHostException
    {
        // Refresh the address, hope their DNS TTL settings allow this.
<span class="fc" id="L291">        InetSocketAddress socketAddress = new InetSocketAddress(remoteAddress, port);</span>

<span class="fc bfc" id="L293" title="All 2 branches covered.">        if (socketAddress.isUnresolved())</span>
        {
<span class="fc" id="L295">            throw new UnknownHostException(&quot;RiakNode:start - Failed resolving host &quot; + remoteAddress);</span>
        }

<span class="fc" id="L298">        bootstrap.remoteAddress(socketAddress);</span>
<span class="fc" id="L299">    }</span>

    public synchronized Future&lt;Boolean&gt; shutdown()
    {
<span class="fc" id="L303">        stateCheck(State.RUNNING, State.HEALTH_CHECKING);</span>
<span class="fc" id="L304">        state = State.SHUTTING_DOWN;</span>
<span class="fc" id="L305">        logger.info(&quot;RiakNode shutting down; {}:{}&quot;, remoteAddress, port);</span>
<span class="fc" id="L306">        notifyStateListeners();</span>
<span class="fc" id="L307">        idleReaperFuture.cancel(true);</span>
<span class="fc" id="L308">        healthMonitorFuture.cancel(true);</span>
<span class="fc" id="L309">        ChannelWithIdleTime cwi = available.poll();</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">        while (cwi != null)</span>
        {
<span class="fc" id="L312">            Channel c = cwi.getChannel();</span>
<span class="fc" id="L313">            closeConnection(c);</span>
<span class="fc" id="L314">            cwi = available.poll();</span>
<span class="fc" id="L315">        }</span>

<span class="fc" id="L317">        executor.schedule(new ShutdownTask(), 0, TimeUnit.SECONDS);</span>

<span class="fc" id="L319">        return new Future&lt;Boolean&gt;()</span>
<span class="fc" id="L320">        {</span>
            @Override
            public boolean cancel(boolean mayInterruptIfRunning)
            {
<span class="nc" id="L324">                return false;</span>
            }
            @Override
            public Boolean get() throws InterruptedException
            {
<span class="fc" id="L329">                shutdownLatch.await();</span>
<span class="fc" id="L330">                return true;</span>
            }
            @Override
            public Boolean get(long timeout, TimeUnit unit) throws InterruptedException
            {
<span class="nc" id="L335">                return shutdownLatch.await(timeout, unit);</span>
            }
            @Override
            public boolean isCancelled()
            {
<span class="nc" id="L340">                return false;</span>
            }
            @Override
            public boolean isDone()
            {
<span class="nc bnc" id="L345" title="All 2 branches missed.">                return shutdownLatch.getCount() &lt;= 0;</span>
            }
        };
    }

    /**
     * Sets the Netty {@link Bootstrap} for this Node's connections.
     * {@link Bootstrap#clone()} is called to clone the bootstrap.
     *
     * @param bootstrap - the Netty Bootstrap to use
     * @return a reference to this RiakNode
     * @throws IllegalArgumentException if it was already set via the builder.
     * @throws IllegalStateException    if the node has already been started.
     * @see Builder#withBootstrap(io.netty.bootstrap.Bootstrap)
     */
    public RiakNode setBootstrap(Bootstrap bootstrap)
    {
<span class="fc" id="L362">        stateCheck(State.CREATED);</span>
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">        if (this.bootstrap != null)</span>
        {
<span class="nc" id="L365">            throw new IllegalArgumentException(&quot;Bootstrap already set&quot;);</span>
        }

<span class="fc" id="L368">        this.bootstrap = bootstrap.clone();</span>
<span class="fc" id="L369">        return this;</span>
    }

    /**
     * Sets the {@link ScheduledExecutorService} for this Node and its pool(s).
     *
     * @param executor - the ScheduledExecutorService to use.
     * @return a reference to this RiakNode
     * @throws IllegalArgumentException if it was already set via the builder.
     * @throws IllegalStateException    if the node has already been started.
     * @see Builder#withExecutor(java.util.concurrent.ScheduledExecutorService)
     */
    public RiakNode setExecutor(ScheduledExecutorService executor)
    {
<span class="fc" id="L383">        stateCheck(State.CREATED);</span>
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">        if (this.executor != null)</span>
        {
<span class="nc" id="L386">            throw new IllegalArgumentException(&quot;Executor already set&quot;);</span>
        }
<span class="fc" id="L388">        this.executor = executor;</span>
<span class="fc" id="L389">        return this;</span>
    }

    /**
     * Sets the maximum number of connections allowed.
     *
     * @param maxConnections the maxConnections to set.
     * @return a reference to this RiakNode.
     * @see Builder#withMaxConnections(int)
     */
    public RiakNode setMaxConnections(int maxConnections)
    {
<span class="fc" id="L401">        stateCheck(State.CREATED, State.RUNNING, State.HEALTH_CHECKING);</span>
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">        if (maxConnections &gt;= getMinConnections())</span>
        {
<span class="fc" id="L404">            permits.setMaxPermits(maxConnections);</span>
        }
        else
        {
<span class="nc" id="L408">            throw new IllegalArgumentException(&quot;Max connections less than min connections&quot;);</span>
        }
        // TODO: reap delta?
<span class="fc" id="L411">        return this;</span>
    }

    /**
     * Returns the maximum number of connections allowed.
     *
     * @return the maxConnections
     * @see Builder#withMaxConnections(int)
     */
    public int getMaxConnections()
    {
<span class="fc" id="L422">        stateCheck(State.CREATED, State.RUNNING, State.HEALTH_CHECKING);</span>
<span class="fc" id="L423">        return permits.getMaxPermits();</span>
    }

    /**
     * Sets the minimum number of active connections to be maintained.
     *
     * @param minConnections the minConnections to set
     * @return a reference to this RiakNode
     * @see Builder#withMinConnections(int)
     */
    public RiakNode setMinConnections(int minConnections)
    {
<span class="nc" id="L435">        stateCheck(State.CREATED, State.RUNNING, State.HEALTH_CHECKING);</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">        if (minConnections &lt;= getMaxConnections())</span>
        {
<span class="nc" id="L438">            this.minConnections = minConnections;</span>
        }
        else
        {
<span class="nc" id="L442">            throw new IllegalArgumentException(&quot;Min connections greater than max connections&quot;);</span>
        }
        // TODO: Start / reap delta?
<span class="nc" id="L445">        return this;</span>
    }

    /**
     * Returns the current minimum number of active connections to be maintained.
     *
     * @return the minConnections
     * @see Builder#withMinConnections(int)
     */
    public int getMinConnections()
    {
<span class="fc" id="L456">        stateCheck(State.CREATED, State.RUNNING, State.HEALTH_CHECKING);</span>
<span class="fc" id="L457">        return minConnections;</span>
    }

    /**
     * Set whether to block when all connections are in use.
     * @param block true to block.
     * @see Builder#withBlockOnMaxConnections(boolean)
     */
    public void setBlockOnMaxConnections(boolean block)
    {
<span class="nc" id="L467">        this.blockOnMaxConnections = block;</span>
<span class="nc" id="L468">    }</span>

    /**
     * Returns if this node is set to block when all connections are in use.
     * @return true if set to block, false otherwise.
     * @see Builder#withBlockOnMaxConnections(boolean)
     */
    public boolean getBlockOnMaxConnections()
    {
<span class="nc" id="L477">        return blockOnMaxConnections;</span>
    }

    /**
     * Sets the connection idle timeout for connections.
     *
     * @param idleTimeoutInMillis the idleTimeout to set
     * @return a reference to this RiakNode
     * @see Builder#withIdleTimeout(int)
     */
    public RiakNode setIdleTimeout(int idleTimeoutInMillis)
    {
<span class="nc" id="L489">        stateCheck(State.CREATED, State.RUNNING, State.HEALTH_CHECKING);</span>
<span class="nc" id="L490">        this.idleTimeoutInNanos = TimeUnit.NANOSECONDS.convert(idleTimeoutInMillis, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L491">        return this;</span>
    }

    /**
     * Returns the connection idle timeout for connections in milliseconds.
     *
     * @return the idleTimeout in milliseconds
     * @see Builder#withIdleTimeout(int)
     */
    public int getIdleTimeout()
    {
<span class="fc" id="L502">        stateCheck(State.CREATED, State.RUNNING, State.HEALTH_CHECKING);</span>
<span class="fc" id="L503">        return (int) TimeUnit.MILLISECONDS.convert(idleTimeoutInNanos, TimeUnit.NANOSECONDS);</span>
    }

    /**
     * Sets the connection timeout for new connections.
     *
     * @param connectionTimeoutInMillis the connectionTimeout to set
     * @return a reference to this RiakNode
     * @see Builder#withConnectionTimeout(int)
     */
    public RiakNode setConnectionTimeout(int connectionTimeoutInMillis)
    {
<span class="nc" id="L515">        stateCheck(State.CREATED, State.RUNNING, State.HEALTH_CHECKING);</span>
<span class="nc" id="L516">        this.connectionTimeout = connectionTimeoutInMillis;</span>
<span class="nc" id="L517">        bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, connectionTimeout);</span>
<span class="nc" id="L518">        return this;</span>
    }

    /**
     * Returns the connection timeout in milliseconds.
     *
     * @return the connectionTimeout
     * @see Builder#withConnectionTimeout(int)
     */
    public int getConnectionTimeout()
    {
<span class="fc" id="L529">        stateCheck(State.CREATED, State.RUNNING, State.HEALTH_CHECKING);</span>
<span class="fc" id="L530">        return connectionTimeout;</span>
    }

    /**
     * Returns the number of permits currently available.
     * The number of available permits indicates how many additional
     * connections can be made without blocking.
     *
     * @return the number of available permits.
     * @see Builder#withMaxConnections(int)
     */
    public int availablePermits()
    {
<span class="fc" id="L543">        stateCheck(State.CREATED, State.RUNNING, State.HEALTH_CHECKING);</span>
<span class="fc" id="L544">        return permits.availablePermits();</span>
    }

    public void addStateListener(NodeStateListener listener)
    {
<span class="fc" id="L549">        stateListeners.add(listener);</span>
<span class="fc" id="L550">    }</span>

    public boolean removeStateListener(NodeStateListener listener)
    {
<span class="fc" id="L554">        return stateListeners.remove(listener);</span>
    }

    private void notifyStateListeners()
    {
<span class="fc" id="L559">        synchronized (stateListeners)</span>
        {
<span class="fc bfc" id="L561" title="All 2 branches covered.">            for (NodeStateListener listener : stateListeners)</span>
            {
<span class="fc" id="L563">                listener.nodeStateChanged(this, state);</span>
<span class="fc" id="L564">            }</span>
<span class="pc" id="L565">        }</span>
<span class="fc" id="L566">    }</span>

    /**
     * Submits the operation to be executed on this node.
     *
     * @param operation The operation to perform
     * @return {@code true} if this operation was accepted, {@code false} if there
     *         were no available connections.
     * @throws IllegalStateException    if this node is not in the {@code RUNNING} or {@code HEALTH_CHECKING} state
     * @throws IllegalArgumentException if the protocol required for the operation is not supported by this node
     */
    public boolean execute(FutureOperation operation)
    {
<span class="fc" id="L579">        stateCheck(State.RUNNING, State.HEALTH_CHECKING);</span>

<span class="fc" id="L581">        operation.setLastNode(this);</span>
<span class="fc" id="L582">        Channel channel = getConnection();</span>
<span class="fc bfc" id="L583" title="All 2 branches covered.">        if (channel != null)</span>
        {
<span class="fc" id="L585">            inProgressMap.put(channel, operation);</span>
<span class="fc" id="L586">            ChannelFuture writeFuture = channel.writeAndFlush(operation);</span>
<span class="fc" id="L587">            writeFuture.addListener(writeListener);</span>
<span class="fc" id="L588">            logger.debug(&quot;Operation {} being executed on RiakNode {}:{}&quot;,</span>
<span class="fc" id="L589">                         System.identityHashCode(operation), remoteAddress, port);</span>
<span class="fc" id="L590">            return true;</span>
        }
        else
        {
<span class="fc" id="L594">            logger.debug(&quot;Operation {} not being executed Riaknode {}:{}; no connections available&quot;,</span>
<span class="fc" id="L595">                         System.identityHashCode(operation), remoteAddress, port);</span>
<span class="fc" id="L596">            return false;</span>
        }
    }

    // ConnectionPool Stuff

    /**
     * Get a Netty channel from the pool.
     * &lt;p&gt;
     * The first thing this method does is attempt to acquire a permit from the
     * Semaphore that controls the pool's behavior. Depending on whether
     * {@code blockOnMaxConnections} is set, this will either block until one
     * becomes available or return null.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Once a permit has been acquired, a channel from the pool or a newly
     * created one will be returned. If an attempt to create a new connection
     * fails, null will then be returned.
     * &lt;/p&gt;
     * @return a connected channel or {@code null}
     * @see Builder#withBlockOnMaxConnections(boolean)
     */
    private Channel getConnection()
    {
<span class="fc" id="L620">        stateCheck(State.RUNNING, State.HEALTH_CHECKING);</span>
<span class="fc" id="L621">        boolean acquired = false;</span>
<span class="fc bfc" id="L622" title="All 2 branches covered.">        if (blockOnMaxConnections)</span>
        {
            try
            {
<span class="fc" id="L626">                logger.debug(&quot;Attempting to acquire channel permit&quot;);</span>

<span class="fc bfc" id="L628" title="All 2 branches covered.">                if (!permits.tryAcquire())</span>
                {
<span class="fc" id="L630">                    logger.info(&quot;All connections in use for {}; had to wait for one.&quot;,</span>
                                remoteAddress);
<span class="nc" id="L632">                    permits.acquire();</span>
                }
<span class="fc" id="L634">                acquired = true;</span>
            }
<span class="nc" id="L636">            catch (InterruptedException ex)</span>
            {
                // no-op, don't care
            }
<span class="fc" id="L640">            catch (BlockingOperationException ex)</span>
            {
<span class="fc" id="L642">                logger.error(&quot;Netty interrupted waiting for connection permit to be available; {}&quot;,</span>
                             remoteAddress);
<span class="pc" id="L644">            }</span>
        }
        else
        {
<span class="fc" id="L648">            logger.debug(&quot;Attempting to acquire channel permit&quot;);</span>
<span class="fc" id="L649">            acquired = permits.tryAcquire();</span>
        }

<span class="fc" id="L652">        Channel channel = null;</span>
<span class="fc bfc" id="L653" title="All 2 branches covered.">        if (acquired)</span>
        {
            try
            {
<span class="fc" id="L657">                channel = doGetConnection(true);</span>
<span class="fc" id="L658">                channel.closeFuture().removeListener(inAvailableCloseListener);</span>
            }
<span class="fc" id="L660">            catch (ConnectionFailedException ex)</span>
            {
<span class="fc" id="L662">                permits.release();</span>
            }
<span class="nc" id="L664">            catch (UnknownHostException ex)</span>
            {
<span class="nc" id="L666">                permits.release();</span>
<span class="nc" id="L667">                logger.error(&quot;Unknown host encountered while trying to open connection; {}&quot;, ex);</span>
<span class="fc" id="L668">            }</span>
        }
<span class="fc" id="L670">        return channel;</span>
    }

    private Channel doGetConnection(boolean forceAddressRefresh) throws ConnectionFailedException, UnknownHostException
    {
        ChannelWithIdleTime cwi;
<span class="fc bfc" id="L676" title="All 2 branches covered.">        while ((cwi = available.poll()) != null)</span>
        {
<span class="fc" id="L678">            Channel channel = cwi.getChannel();</span>
            // If the channel from available is closed, try again. This will result in
            // the caller always getting a connection or an exception. If closed
            // the channel is simply discarded so this also acts as a purge
            // for dead channels during a health check.
<span class="fc bfc" id="L683" title="All 2 branches covered.">            if (channel.isOpen())</span>
            {
<span class="fc" id="L685">                return channel;</span>
            }
<span class="fc" id="L687">        }</span>

<span class="fc bfc" id="L689" title="All 2 branches covered.">        if (forceAddressRefresh)</span>
        {
<span class="fc" id="L691">            refreshBootstrapRemoteAddress();</span>
        }

<span class="fc" id="L694">        ChannelFuture f = bootstrap.connect();</span>

        try
        {
<span class="fc" id="L698">            f.await();</span>
        }
<span class="nc" id="L700">        catch (InterruptedException ex)</span>
        {
<span class="nc" id="L702">            logger.error(&quot;Thread interrupted waiting for new connection to be made; {}&quot;,</span>
                remoteAddress);
<span class="nc" id="L704">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L705">            throw new ConnectionFailedException(ex);</span>
        }
<span class="fc" id="L707">        catch (BlockingOperationException ex)</span>
        {
<span class="fc" id="L709">            logger.error(&quot;Netty interrupted waiting for new connection to be made; {}&quot;,</span>
                         remoteAddress);
<span class="fc" id="L711">            throw new ConnectionFailedException(ex);</span>
<span class="fc" id="L712">        }</span>

<span class="fc bfc" id="L714" title="All 2 branches covered.">        if (!f.isSuccess())</span>
        {
<span class="fc" id="L716">            logger.error(&quot;Connection attempt failed: {}:{}; {}&quot;,</span>
<span class="fc" id="L717">                remoteAddress, port, f.cause());</span>
<span class="fc" id="L718">            consecutiveFailedConnectionAttempts.incrementAndGet();</span>
<span class="fc" id="L719">            throw new ConnectionFailedException(f.cause());</span>
        }

<span class="fc" id="L722">        consecutiveFailedConnectionAttempts.set(0);</span>
<span class="fc" id="L723">        Channel c = f.channel();</span>

<span class="pc bpc" id="L725" title="1 of 2 branches missed.">        if (trustStore != null)</span>
        {
<span class="nc" id="L727">            setupTLSAndAuthenticate(c);</span>
        }

<span class="fc" id="L730">        return c;</span>
    }

    private void setupTLSAndAuthenticate(Channel c) throws ConnectionFailedException
    {
        SSLContext context;
        try
        {
<span class="nc" id="L738">            context = SSLContext.getInstance(&quot;TLS&quot;);</span>
            TrustManagerFactory tmf =
<span class="nc" id="L740">                TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());</span>
<span class="nc" id="L741">            tmf.init(trustStore);</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">                if (keyStore!=null)</span>
            {
<span class="nc" id="L744">                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">                kmf.init(keyStore, keyPassword==null?&quot;&quot;.toCharArray():keyPassword.toCharArray());</span>
<span class="nc" id="L746">                context.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);</span>
<span class="nc" id="L747">            }</span>
            else
            {
<span class="nc" id="L750">                context.init(null, tmf.getTrustManagers(), null);</span>
            }
        }
<span class="nc" id="L753">        catch (Exception ex)</span>
        {
<span class="nc" id="L755">            c.close();</span>
<span class="nc" id="L756">            logger.error(&quot;Failure configuring SSL; {}:{} {}&quot;, remoteAddress, port, ex);</span>
<span class="nc" id="L757">            throw new ConnectionFailedException(ex);</span>
<span class="nc" id="L758">        }</span>

<span class="nc" id="L760">        SSLEngine engine = context.createSSLEngine();</span>

<span class="nc" id="L762">        Set&lt;String&gt; protocols = new HashSet&lt;&gt;(Arrays.asList(engine.getSupportedProtocols()));</span>

<span class="nc bnc" id="L764" title="All 2 branches missed.">        if (protocols.contains(&quot;TLSv1.2&quot;))</span>
        {
<span class="nc" id="L766">            engine.setEnabledProtocols(new String[] {&quot;TLSv1.2&quot;});</span>
<span class="nc" id="L767">            logger.debug(&quot;Using TLSv1.2&quot;);</span>
        }
<span class="nc bnc" id="L769" title="All 2 branches missed.">        else if (protocols.contains(&quot;TLSv1.1&quot;))</span>
        {
<span class="nc" id="L771">            engine.setEnabledProtocols(new String[] {&quot;TLSv1.1&quot;});</span>
<span class="nc" id="L772">            logger.debug(&quot;Using TLSv1.1&quot;);</span>
        }

<span class="nc" id="L775">        engine.setUseClientMode(true);</span>
<span class="nc" id="L776">        RiakSecurityDecoder decoder = new RiakSecurityDecoder(engine, username, password);</span>
<span class="nc" id="L777">        c.pipeline().addFirst(decoder);</span>

        try
        {
<span class="nc" id="L781">            DefaultPromise&lt;Void&gt; promise = decoder.getPromise();</span>
<span class="nc" id="L782">                logger.debug(&quot;Waiting on SSL Promise&quot;);</span>
<span class="nc" id="L783">            promise.await();</span>

<span class="nc bnc" id="L785" title="All 2 branches missed.">            if (promise.isSuccess())</span>
            {
<span class="nc" id="L787">                logger.debug(&quot;Auth succeeded; {}:{}&quot;, remoteAddress, port);</span>
            }
            else
            {
<span class="nc" id="L791">                c.close();</span>
<span class="nc" id="L792">                logger.error(&quot;Failure during Auth; {}:{} {}&quot;,remoteAddress, port, promise.cause());</span>
<span class="nc" id="L793">                throw new ConnectionFailedException(promise.cause());</span>
            }
        }
<span class="nc" id="L796">        catch (InterruptedException e)</span>
        {
<span class="nc" id="L798">            c.close();</span>
<span class="nc" id="L799">            logger.error(&quot;Thread interrupted during Auth; {}:{}&quot;,</span>
<span class="nc" id="L800">                remoteAddress, port);</span>
<span class="nc" id="L801">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L802">            throw new ConnectionFailedException(e);</span>
<span class="nc" id="L803">        }</span>
<span class="nc" id="L804">    }</span>

    /**
     * Return a Netty channel.
     *
     * @param c The Netty channel to return to the pool
     */
    private void returnConnection(Channel c)
    {
<span class="pc bpc" id="L813" title="1 of 2 branches missed.">        switch (state)</span>
        {
            case SHUTTING_DOWN:
            case SHUTDOWN:
<span class="nc" id="L817">                closeConnection(c);</span>
<span class="nc" id="L818">                break;</span>
            case RUNNING:
            case HEALTH_CHECKING:
            default:
<span class="pc bpc" id="L822" title="1 of 2 branches missed.">                if (inProgressMap.containsKey(c))</span>
                {
<span class="nc" id="L824">                    logger.error(&quot;Channel returned to pool while still in use. id: {}&quot;,</span>
<span class="nc" id="L825">                        c.hashCode());</span>
                }
                else
                {
<span class="fc bfc" id="L829" title="All 2 branches covered.">                    if (c.isOpen())</span>
                    {
<span class="fc" id="L831">                        logger.debug(&quot;Channel id:{} returned to pool&quot;, c.hashCode());</span>
<span class="fc" id="L832">                        c.closeFuture().removeListener(inProgressCloseListener);</span>
<span class="fc" id="L833">                        c.closeFuture().addListener(inAvailableCloseListener);</span>
<span class="fc" id="L834">                        available.offerFirst(new ChannelWithIdleTime(c));</span>
                    }
                    else
                    {
<span class="fc" id="L838">                        logger.debug(&quot;Closed channel id:{} returned to pool; discarding&quot;, c.hashCode());</span>
                    }
<span class="fc" id="L840">                    logger.debug(&quot;Released pool permit&quot;);</span>
<span class="fc" id="L841">                    permits.release();</span>
                }
            }
<span class="fc" id="L844">    }</span>

    private void closeConnection(Channel c)
    {
        // If we are explicitly closing the connection we don't want to hear
        // about it.
<span class="fc" id="L850">        c.closeFuture().removeListener(inProgressCloseListener);</span>
<span class="fc" id="L851">        c.closeFuture().removeListener(inAvailableCloseListener);</span>
<span class="fc" id="L852">        c.close();</span>
<span class="fc" id="L853">    }</span>

    // End ConnectionPool stuff

    @Override
    public void onSuccess(Channel channel, final RiakMessage response)
    {
<span class="fc" id="L860">        logger.debug(&quot;Operation onSuccess() channel: id:{} {}:{}&quot;, channel.hashCode(), remoteAddress, port);</span>
<span class="fc" id="L861">        consecutiveFailedOperations.set(0);</span>
<span class="fc" id="L862">        final FutureOperation inProgress = inProgressMap.get(channel);</span>

        // Especially with a streaming op, the close listener may trigger causing
        // a race. This check guards that.
<span class="pc bpc" id="L866" title="1 of 2 branches missed.">        if (inProgress != null)</span>
        {
<span class="fc" id="L868">            inProgress.setResponse(response);</span>

<span class="pc bpc" id="L870" title="1 of 2 branches missed.">            if (inProgress.isDone())</span>
            {
                try
                {
<span class="fc" id="L874">                    inProgressMap.remove(channel);</span>
<span class="fc" id="L875">                    returnConnection(channel); // return permit</span>
                }
                finally
                {
<span class="pc" id="L879">                    inProgress.setComplete();</span>
<span class="fc" id="L880">                }</span>
            }
        }
<span class="fc" id="L883">    }</span>

    @Override
    public void onRiakErrorResponse(Channel channel, RiakResponseException ex)
    {
<span class="fc" id="L888">        logger.debug(&quot;Riak replied with error; {}:{}&quot;, ex.getCode(), ex.getMessage());</span>
<span class="fc" id="L889">        final FutureOperation inProgress = inProgressMap.remove(channel);</span>
<span class="fc" id="L890">        consecutiveFailedOperations.incrementAndGet();</span>
<span class="pc bpc" id="L891" title="1 of 2 branches missed.">        if (inProgress != null)</span>
        {
<span class="fc" id="L893">            returnConnection(channel); // release permit</span>
<span class="fc" id="L894">            inProgress.setException(ex);</span>
        }
<span class="fc" id="L896">    }</span>

    @Override
    public void onException(Channel channel, final Throwable t)
    {
<span class="fc" id="L901">        logger.error(&quot;Operation onException() channel: id:{} {}:{} {}&quot;,</span>
<span class="fc" id="L902">            channel.hashCode(), remoteAddress, port, t);</span>

<span class="fc" id="L904">        final FutureOperation inProgress = inProgressMap.remove(channel);</span>
        // There are fail cases where multiple exceptions are thrown from
        // the pipeline. In that case we'll get an exception from the
        // handler but will not have an entry in inProgress because it's
        // already been handled.
<span class="pc bpc" id="L909" title="1 of 2 branches missed.">        if (inProgress != null)</span>
        {
<span class="fc" id="L911">            returnConnection(channel); // release permit</span>
<span class="fc" id="L912">            inProgress.setException(t);</span>
        }
<span class="fc" id="L914">    }</span>

    private void checkNetworkAddressCacheSettings()
    {
<span class="fc" id="L918">        final String property = Security.getProperty(&quot;networkaddress.cache.ttl&quot;);</span>

<span class="pc bpc" id="L920" title="1 of 2 branches missed.">        final boolean usingSecurityMgr = System.getSecurityManager() != null;</span>
<span class="pc bpc" id="L921" title="1 of 2 branches missed.">        final boolean propertyUndefined = property == null;</span>
<span class="fc" id="L922">        boolean logWarning = false;</span>

<span class="pc bpc" id="L924" title="2 of 4 branches missed.">        if (propertyUndefined &amp;&amp; usingSecurityMgr)</span>
        {
<span class="nc" id="L926">            logWarning = true;</span>
        }
<span class="pc bpc" id="L928" title="1 of 2 branches missed.">        else if (!propertyUndefined)</span>
        {
<span class="nc" id="L930">            final int cacheTTL = Integer.parseInt(property);</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">            logWarning = (cacheTTL == -1);</span>
        }

<span class="pc bpc" id="L934" title="1 of 2 branches missed.">        if (logWarning)</span>
        {
<span class="nc" id="L936">            logger.warn(</span>
                    &quot;The Java Security \&quot;networkaddress.cache.ttl\&quot; property may be set to cache DNS lookups forever. &quot; +
                    &quot;Using domain names for Riak nodes or an intermediate load balancer could result in stale IP &quot; +
                    &quot;addresses being used for new connections, causing connection errors. &quot; +
                    &quot;If you use domain names for Riak nodes, please set this property to a value greater than zero.&quot;);
        }
<span class="fc" id="L942">    }</span>

    /**
     * Returns the {@code remoteAddress} for this RiakNode
     *
     * @return The IP address or FQDN as a {@code String}
     */
    public String getRemoteAddress()
    {
<span class="fc" id="L951">        return remoteAddress;</span>
    }

    /**
     * returns the remote port for this RiakNode
     *
     * @return the port number
     */
    public int getPort()
    {
<span class="fc" id="L961">        return port;</span>
    }

    /**
     * Returns the current state of this node.
     *
     * @return The state
     */
    public State getNodeState()
    {
<span class="fc" id="L971">        return this.state;</span>
    }

    private class ChannelWithIdleTime
    {
        private Channel channel;
        private long idleStart;

        public ChannelWithIdleTime(Channel channel)
<span class="fc" id="L980">        {</span>
<span class="fc" id="L981">            this.channel = channel;</span>
<span class="fc" id="L982">            idleStart = System.nanoTime();</span>
<span class="fc" id="L983">        }</span>

        public Channel getChannel()
        {
<span class="fc" id="L987">            return channel;</span>
        }

        public long getIdleStart()
        {
<span class="fc" id="L992">            return idleStart;</span>
        }
    }

    static class Sync extends Semaphore
    {
        private static final long serialVersionUID = -5118488872281021072L;
        private volatile int maxPermits;

        public Sync(int numPermits)
        {
<span class="fc" id="L1003">            super(numPermits);</span>
<span class="fc" id="L1004">            this.maxPermits = numPermits;</span>
<span class="fc" id="L1005">        }</span>

        public Sync(int numPermits, boolean fair)
        {
<span class="nc" id="L1009">            super(numPermits, fair);</span>
<span class="nc" id="L1010">            this.maxPermits = numPermits;</span>
<span class="nc" id="L1011">        }</span>

        public int getMaxPermits()
        {
<span class="fc" id="L1015">            return maxPermits;</span>
        }

        // Synchronized because we're (potentially) changing this.maxPermits
        synchronized void setMaxPermits(int maxPermits)
        {
<span class="fc" id="L1021">            int diff = maxPermits - this.maxPermits;</span>

<span class="pc bpc" id="L1023" title="1 of 2 branches missed.">            if (diff == 0)</span>
            {
<span class="nc" id="L1025">                return;</span>
            }
<span class="pc bpc" id="L1027" title="1 of 2 branches missed.">            else if (diff &gt; 0)</span>
            {
<span class="fc" id="L1029">                release(diff);</span>
            }
<span class="nc bnc" id="L1031" title="All 2 branches missed.">            else if (diff &lt; 0)</span>
            {
<span class="nc" id="L1033">                reducePermits(diff);</span>
            }

<span class="fc" id="L1036">            this.maxPermits = maxPermits;</span>
<span class="fc" id="L1037">        }</span>
    }

<span class="fc" id="L1040">    private class IdleReaper implements Runnable</span>
    {
        @Override
        public void run()
        {
<span class="fc" id="L1045">            reapIdleConnections();</span>
<span class="fc" id="L1046">        }</span>
    }

    private void reapIdleConnections()
    {
        // with all the concurrency there's really no reason to keep
        // checking the sizes. This is really just a &quot;best guess&quot;
<span class="fc" id="L1053">        int currentNum = inProgressMap.size() + available.size();</span>
<span class="fc bfc" id="L1054" title="All 2 branches covered.">        if (currentNum &gt; minConnections)</span>
        {
            // Note this will not throw a ConncurrentModificationException
            // and if hasNext() returns true you are guaranteed that
            // the next() will return a value (even if it has already
            // been removed from the Deque between those calls).
<span class="fc" id="L1060">            Iterator&lt;ChannelWithIdleTime&gt; i = available.descendingIterator();</span>
<span class="pc bpc" id="L1061" title="1 of 4 branches missed.">            while (i.hasNext() &amp;&amp; currentNum &gt; minConnections)</span>
            {
<span class="fc" id="L1063">                ChannelWithIdleTime cwi = i.next();</span>
<span class="pc bpc" id="L1064" title="1 of 2 branches missed.">                if (cwi.getIdleStart() + idleTimeoutInNanos &lt; System.nanoTime())</span>
                {
<span class="fc" id="L1066">                    boolean removed = available.remove(cwi);</span>
<span class="pc bpc" id="L1067" title="1 of 2 branches missed.">                    if (removed)</span>
                    {
<span class="fc" id="L1069">                        Channel c = cwi.getChannel();</span>
<span class="fc" id="L1070">                        logger.debug(&quot;Idle channel closed; {}:{}&quot;, remoteAddress, port);</span>
<span class="fc" id="L1071">                        closeConnection(c);</span>
<span class="fc" id="L1072">                        currentNum--;</span>
                    }
                }
                else
                {
                    // Since we are descending and this is a LIFO,
                    // if the current connection hasn't been idle beyond
                    // the threshold, there's no reason to descend further
                    break;
                }
<span class="fc" id="L1082">            }</span>
        }
<span class="fc" id="L1084">    }</span>

    // TODO: Revisit if we ever support multiple protocols or change protocols.
    // As-is the parameters work well for protocol buffers.
    /**
     * Task to see if a criteria should trigger a health check.
     * &lt;p&gt;
     * We keep a list of connections that triggered the closeListener. We also
     * track the number of consecutive failed connection attempts, and the
     * number of consecutive error responses from Riak.
     * &lt;/p&gt;
     */
<span class="fc" id="L1096">    private class HealthMonitorTask implements Runnable</span>
    {
        @Override
        public void run()
        {
            // Purge recentlyClosed past a certain age
            // sliding window should be larger than the
            // frequency of this task
<span class="fc" id="L1104">            long current = System.nanoTime();</span>
<span class="fc" id="L1105">            long window = 3000000000L; // 3 seconds</span>
<span class="fc" id="L1106">            for (ChannelWithIdleTime cwi = recentlyClosed.peek();</span>
<span class="pc bpc" id="L1107" title="1 of 4 branches missed.">                 cwi != null &amp;&amp; current - cwi.getIdleStart() &gt; window;</span>
<span class="nc" id="L1108">                 cwi = recentlyClosed.peek())</span>
            {
<span class="nc" id="L1110">                recentlyClosed.poll();</span>
            }

            // If we more than 5 recently closed in 3 seconds, more than 1 consecutive failed
            // connection attempts, more than 5 consecutive error responses from Riak,
            // or we failed a healthcheck
<span class="fc bfc" id="L1116" title="All 2 branches covered.">            if ((state == State.RUNNING &amp;&amp;</span>
<span class="fc bfc" id="L1117" title="All 2 branches covered.">                    (recentlyClosed.size() &gt; 5 ||</span>
<span class="fc bfc" id="L1118" title="All 2 branches covered.">                     consecutiveFailedConnectionAttempts.get() &gt; 1 ||</span>
<span class="fc bfc" id="L1119" title="All 2 branches covered.">                     consecutiveFailedOperations.get() &gt; 5)</span>
                 ) ||
<span class="fc bfc" id="L1121" title="All 2 branches covered.">                state == State.HEALTH_CHECKING)</span>
            {
<span class="fc" id="L1123">                checkHealth();</span>
            }
<span class="fc" id="L1125">        }</span>
    }

    private void checkHealth()
    {
        try
        {
<span class="fc" id="L1132">            HealthCheckDecoder healthCheck = healthCheckFactory.makeDecoder();</span>
<span class="fc" id="L1133">            RiakFuture&lt;RiakMessage, Void&gt; future = healthCheck.getFuture();</span>
            // See: doGetConnection() - this will purge closed
            // connections from the available queue and either
            // return/create a new one (meaning the node is up) or throw
            // an exception if a connection can't be made.
<span class="fc" id="L1138">            Channel c = doGetConnection(true);</span>
<span class="fc" id="L1139">            logger.debug(&quot;Healthcheck channel: {} isOpen: {} handlers:{}&quot;, c.hashCode(), c.isOpen(), c.pipeline().names());</span>

            // If the channel closes between when we got it and now, the pipeline is emptied. If the handlers
            // aren't there we fail the healthcheck

            try
            {
<span class="pc bpc" id="L1146" title="1 of 2 branches missed.">                if (c.pipeline().names().contains(Constants.SSL_HANDLER))</span>
                {
<span class="nc" id="L1148">                    c.pipeline().addAfter(Constants.SSL_HANDLER, Constants.HEALTHCHECK_CODEC, healthCheck);</span>
                }
                else
                {
<span class="fc" id="L1152">                    c.pipeline().addBefore(Constants.MESSAGE_CODEC, Constants.HEALTHCHECK_CODEC, healthCheck);</span>
                }

<span class="fc" id="L1155">                logger.debug(&quot;healthCheck added to pipeline.&quot;);</span>

                //future.await(5, TimeUnit.SECONDS);
<span class="fc" id="L1158">                future.await();</span>
<span class="fc bfc" id="L1159" title="All 2 branches covered.">                if (future.isSuccess())</span>
                {
<span class="fc" id="L1161">                    healthCheckSucceeded();</span>
                }
                else
                {
<span class="fc" id="L1165">                    healthCheckFailed(future.cause());</span>
                }
            }
<span class="nc" id="L1168">            catch (InterruptedException ex)</span>
            {
<span class="nc" id="L1170">                logger.error(&quot;Thread interrupted performing healthcheck.&quot;);</span>
            }
<span class="nc" id="L1172">            catch (NoSuchElementException e)</span>
            {
<span class="nc" id="L1174">                healthCheckFailed(new IOException(&quot;Channel closed during health check&quot;));</span>
            }
            finally
            {
<span class="pc" id="L1178">                closeConnection(c);</span>
<span class="pc" id="L1179">            }</span>
        }
<span class="fc" id="L1181">        catch (ConnectionFailedException | UnknownHostException ex)</span>
        {
<span class="fc" id="L1183">            healthCheckFailed(ex);</span>
        }
<span class="nc" id="L1185">        catch (IllegalStateException ex)</span>
        {
            // no-op; there's a race condition where the bootstrap is shutting down
            // right when a healthcheck occurs and netty will throw this
<span class="nc" id="L1189">            logger.debug(&quot;Illegal state exception during healthcheck.&quot;);</span>
<span class="nc" id="L1190">            logger.debug(&quot;Stack: {}&quot;, ex);</span>
        }
<span class="nc" id="L1192">        catch (RuntimeException ex)</span>
        {
<span class="nc" id="L1194">            logger.error(&quot;Runtime exception during healthcheck: {}&quot;, ex);</span>
<span class="pc" id="L1195">        }</span>
<span class="fc" id="L1196">    }</span>

    private void healthCheckFailed(Throwable cause)
    {
<span class="pc bpc" id="L1200" title="1 of 2 branches missed.">        if (state == State.RUNNING)</span>
        {
<span class="fc" id="L1202">            logger.error(&quot;RiakNode failed healthcheck operation; health checking; {}:{} {}&quot;,</span>
<span class="fc" id="L1203">                remoteAddress, port, cause);</span>
<span class="fc" id="L1204">            state = State.HEALTH_CHECKING;</span>
<span class="fc" id="L1205">            notifyStateListeners();</span>
        }
        else
        {
<span class="nc" id="L1209">            logger.error(&quot;RiakNode failed healthcheck operation; {}:{} {}&quot;,</span>
<span class="nc" id="L1210">                remoteAddress, port, cause);</span>
        }
<span class="fc" id="L1212">    }</span>

    private void healthCheckSucceeded()
    {
<span class="pc bpc" id="L1216" title="1 of 2 branches missed.">        if (state == State.HEALTH_CHECKING)</span>
        {
<span class="fc" id="L1218">            logger.info(&quot;RiakNode recovered; {}:{}&quot;, remoteAddress, port);</span>
<span class="fc" id="L1219">            state = State.RUNNING;</span>
<span class="fc" id="L1220">            notifyStateListeners();</span>
        }
<span class="fc" id="L1222">    }</span>

<span class="fc" id="L1224">    private class ShutdownTask implements Runnable</span>
    {
        @Override
        public void run()
        {
<span class="pc bpc" id="L1229" title="1 of 2 branches missed.">            if (inProgressMap.isEmpty())</span>
            {
<span class="fc" id="L1231">                state = State.SHUTDOWN;</span>
<span class="fc" id="L1232">                notifyStateListeners();</span>
<span class="fc bfc" id="L1233" title="All 2 branches covered.">                if (ownsExecutor)</span>
                {
<span class="fc" id="L1235">                    executor.shutdown();</span>
                }
<span class="fc bfc" id="L1237" title="All 2 branches covered.">                if (ownsBootstrap)</span>
                {
<span class="fc" id="L1239">                    bootstrap.config().group().shutdownGracefully();</span>
                }
<span class="fc" id="L1241">                logger.debug(&quot;RiakNode shut down {}:{}&quot;, remoteAddress, port);</span>
<span class="fc" id="L1242">                shutdownLatch.countDown();</span>
            }
<span class="fc" id="L1244">        }</span>
    }

    /**
     * Builder used to construct a RiakNode.
     */
    public static class Builder
    {
        /**
         * The default remote address to be used if not specified: {@value #DEFAULT_REMOTE_ADDRESS}
         *
         * @see #withRemoteAddress(java.lang.String)
         */
        public final static String DEFAULT_REMOTE_ADDRESS = &quot;127.0.0.1&quot;;
        /**
         * The default port number to be used if not specified: {@value #DEFAULT_REMOTE_PORT}
         *
         * @see #withRemotePort(int)
         */
        public final static int DEFAULT_REMOTE_PORT = 8087;
        /**
         * The default minimum number of connections to maintain if not specified: {@value #DEFAULT_MIN_CONNECTIONS}
         *
         * @see #withMinConnections(int)
         */
        public final static int DEFAULT_MIN_CONNECTIONS = 1;
        /**
         * The default maximum number of connections allowed if not specified: {@value #DEFAULT_MAX_CONNECTIONS}
         *
         * @see #withMaxConnections(int)
         */
        public final static int DEFAULT_MAX_CONNECTIONS = 0;
        /**
         * The default idle timeout in milliseconds for connections if not specified: {@value #DEFAULT_IDLE_TIMEOUT}
         *
         * @see #withIdleTimeout(int)
         */
        public final static int DEFAULT_IDLE_TIMEOUT = 1000;
        /**
         * The default connection timeout in milliseconds if not specified: {@value #DEFAULT_CONNECTION_TIMEOUT}
         *
         * @see #withConnectionTimeout(int)
         */
        public final static int DEFAULT_CONNECTION_TIMEOUT = 0;

        /**
         * The default HealthCheckFactory.
         * &lt;p&gt;
         * By default this is the {@link PingHealthCheck}
         * &lt;/p&gt;
         * @see HealthCheckFactory
         * @see HealthCheckDecoder
         */
<span class="fc" id="L1297">        public final static HealthCheckFactory DEFAULT_HEALTHCHECK_FACTORY = new PingHealthCheck();</span>

<span class="fc" id="L1299">        private int port = DEFAULT_REMOTE_PORT;</span>
<span class="fc" id="L1300">        private String remoteAddress = DEFAULT_REMOTE_ADDRESS;</span>
<span class="fc" id="L1301">        private int minConnections = DEFAULT_MIN_CONNECTIONS;</span>
<span class="fc" id="L1302">        private int maxConnections = DEFAULT_MAX_CONNECTIONS;</span>
<span class="fc" id="L1303">        private int idleTimeout = DEFAULT_IDLE_TIMEOUT;</span>
<span class="fc" id="L1304">        private int connectionTimeout = DEFAULT_CONNECTION_TIMEOUT;</span>
<span class="fc" id="L1305">        private HealthCheckFactory healthCheckFactory = DEFAULT_HEALTHCHECK_FACTORY;</span>
        private Bootstrap bootstrap;
        private ScheduledExecutorService executor;
        private boolean blockOnMaxConnections;
        private String username;
        private String password;
        private KeyStore trustStore;
        private KeyStore keyStore;
        private String keyPassword;

        /**
         * Default constructor. Returns a new builder for a RiakNode with
         * default values set.
         */
        public Builder()
<span class="fc" id="L1320">        {</span>
<span class="fc" id="L1321">        }</span>

        /**
         * Sets the remote host and port for this RiakNode.
         *
         * @param hostAndPOrt
         * @return this
         */
        public Builder withRemoteHost(HostAndPort hostAndPOrt)
        {
<span class="nc" id="L1331">            this.withRemoteAddress(hostAndPOrt.getHost());</span>
<span class="nc" id="L1332">            this.withRemotePort(hostAndPOrt.getPort());</span>
<span class="nc" id="L1333">            return this;</span>
        }

        /**
         * Sets the remote address for this RiakNode.
         *
         * @param remoteAddress Can either be a FQDN or IP address. Since 2.0.3 it may contain port delimited by ':'.
         * @return this
         * @see #DEFAULT_REMOTE_ADDRESS
         */
        public Builder withRemoteAddress(String remoteAddress)
        {
<span class="fc" id="L1345">            withRemoteAddress(HostAndPort.fromString(remoteAddress, this.port));</span>
<span class="fc" id="L1346">            return this;</span>
        }

        /**
         * Specifies the remote port for this RiakNode.
         *
         * @param port - the port
         * @return this
         * @see #DEFAULT_REMOTE_PORT
         */
        public Builder withRemotePort(int port)
        {
<span class="fc" id="L1358">            this.port = port;</span>
<span class="fc" id="L1359">            return this;</span>
        }

        /**
         * Specifies the remote host and remote port for this RiakNode.
         *
         * @param hp - host and port
         * @return this
         * @see #DEFAULT_REMOTE_PORT
         *
         * @since 2.0.3
         * @see HostAndPort
         */
        public Builder withRemoteAddress(HostAndPort hp)
        {
<span class="fc" id="L1374">            this.port = hp.getPortOrDefault(DEFAULT_REMOTE_PORT);</span>
<span class="fc" id="L1375">            this.remoteAddress = hp.getHost();</span>
<span class="fc" id="L1376">            return this;</span>
        }

        /**
         * Set the minimum number of active connections to maintain.
         * These connections are exempt from the idle timeout.
         *
         * @param minConnections - number of connections to maintain.
         * @return this
         * @see #DEFAULT_MIN_CONNECTIONS
         */
        public Builder withMinConnections(int minConnections)
        {
<span class="pc bpc" id="L1389" title="3 of 4 branches missed.">            if (maxConnections == DEFAULT_MAX_CONNECTIONS || minConnections &lt;= maxConnections)</span>
            {
<span class="fc" id="L1391">                this.minConnections = minConnections;</span>
            }
            else
            {
<span class="nc" id="L1395">                throw new IllegalArgumentException(&quot;Min connections greater than max connections&quot;);</span>
            }
<span class="fc" id="L1397">            return this;</span>
        }

        /**
         * Set the maximum number of connections allowed.
         * A value of 0 sets this to unlimited.
         *
         * @param maxConnections - maximum number of connections to allow
         * @return this
         * @see #DEFAULT_MAX_CONNECTIONS
         */
        public Builder withMaxConnections(int maxConnections)
        {
<span class="pc bpc" id="L1410" title="1 of 4 branches missed.">            if (maxConnections == DEFAULT_MAX_CONNECTIONS ||  maxConnections &gt;= minConnections)</span>
            {
<span class="fc" id="L1412">                this.maxConnections = maxConnections;</span>
            }
            else
            {
<span class="nc" id="L1416">                throw new IllegalArgumentException(&quot;Max connections less than min connections&quot;);</span>
            }
<span class="fc" id="L1418">            return this;</span>
        }

        /**
         * Set the idle timeout used to reap inactive connections.
         * Any connection that has been idle for this amount of time
         * becomes eligible to be closed and discarded unless {@code minConnections}
         * has been set via {@link #withMinConnections(int) }
         *
         * @param idleTimeoutInMillis - idle timeout in milliseconds
         * @return this
         * @see #DEFAULT_IDLE_TIMEOUT
         */
        public Builder withIdleTimeout(int idleTimeoutInMillis)
        {
<span class="fc" id="L1433">            this.idleTimeout = idleTimeoutInMillis;</span>
<span class="fc" id="L1434">            return this;</span>
        }

        /**
         * Set the connection timeout used when making new connections
         *
         * @param connectionTimeoutInMillis
         * @return this
         * @see #DEFAULT_CONNECTION_TIMEOUT
         */
        public Builder withConnectionTimeout(int connectionTimeoutInMillis)
        {
<span class="fc" id="L1446">            this.connectionTimeout = connectionTimeoutInMillis;</span>
<span class="fc" id="L1447">            return this;</span>
        }

        /**
         * Provides an executor for this node to use for internal maintenance tasks.
         * If not provided one will be created via
         * {@link Executors#newSingleThreadScheduledExecutor()}
         *
         * @param executor the ScheduledExecutorService to use.
         * @return this
         */
        public Builder withExecutor(ScheduledExecutorService executor)
        {
<span class="fc" id="L1460">            this.executor = executor;</span>
<span class="fc" id="L1461">            return this;</span>
        }

        /**
         * Provides a Netty Bootstrap for this node to use.
         * If not provided one
         * will be created with its own {@code NioEventLoopGroup}.
         *
         * @param bootstrap
         * @return this
         */
        public Builder withBootstrap(Bootstrap bootstrap)
        {
<span class="fc" id="L1474">            this.bootstrap = bootstrap;</span>
<span class="fc" id="L1475">            return this;</span>
        }

        /**
         * Set whether to block if all connections are in use.
         * &lt;p&gt;
         * If a maximum number of connections is specified and all those
         * connections are in use, the default
         * behavior when an operation is submitted to a node is to
         * fail-fast and return. Setting this to true will cause the
         * call to block (fair-scheduled, FIFO) until a connection becomes
         * available.
         * &lt;/p&gt;
         * @param block whether to block when an operation is submitted and
         * all connections are in use.
         * @return this
         */
        public Builder withBlockOnMaxConnections(boolean block)
        {
<span class="fc" id="L1494">            this.blockOnMaxConnections = block;</span>
<span class="fc" id="L1495">            return this;</span>
        }

        /**
         * Set the credentials for Riak security and authentication.
         * &lt;p&gt;
         * Riak supports authentication and authorization features.
         * These credentials will be used for all connections.
         * &lt;/p&gt;
         * &lt;p&gt;
         * Note this requires Riak to have been configured with security enabled.
         * &lt;/p&gt;
         *
         * @param username the riak user name.
         * @param password the password for this user.
         * @param trustStore A Java KeyStore loaded with the CA certificate required for TLS/SSL
         * @return a reference to this object.
         */
        public Builder withAuth(String username, String password, KeyStore trustStore)
        {
<span class="nc" id="L1515">            this.username = username;</span>
<span class="nc" id="L1516">            this.password = password;</span>
<span class="nc" id="L1517">            this.trustStore = trustStore;</span>
<span class="nc" id="L1518">            return this;</span>
        }

        /**
         * Set the credentials for Riak security and authentication.
         * &lt;p&gt;
         * Riak supports authentication and authorization features.
         * These credentials will be used for all connections.
         * &lt;/p&gt;
         * &lt;p&gt;
         * Note this requires Riak to have been configured with security enabled.
         * &lt;/p&gt;
         *
         * @param username the riak user name.
         * @param password the password for this user.
         * @param trustStore A Java KeyStore loaded with the CA certificate required for TLS/SSL
         * @param keyStore A Java KeyStore loaded with User's Private certificate required for TLS/SSL
         * @param keyPassword the password for User's Private certificate.
         * @return a reference to this object.
         */
        public Builder withAuth(String username, String password, KeyStore trustStore, KeyStore keyStore, String keyPassword)
        {
<span class="nc" id="L1540">            this.username = username;</span>
<span class="nc" id="L1541">            this.password = password;</span>
<span class="nc" id="L1542">            this.trustStore = trustStore;</span>
<span class="nc" id="L1543">            this.keyStore = keyStore;</span>
<span class="nc" id="L1544">            this.keyPassword = keyPassword;</span>
<span class="nc" id="L1545">            return this;</span>
        }

        /**
         * Set the HealthCheckFactory used to determine if this RiakNode is healthy.
         * &lt;p&gt;
         * If not set the {@link PingHealthCheck} is used.
         * &lt;/p&gt;
         * @param factory a HealthCheckFactory instance that produces HealthCheckDecoders
         * @return a reference to this object.
         * @see HealthCheckDecoder
         */
        public Builder withHealthCheck(HealthCheckFactory factory)
        {
<span class="nc" id="L1559">            this.healthCheckFactory = factory;</span>
<span class="nc" id="L1560">            return this;</span>
        }

        /**
         * Builds a RiakNode.
         * If a Netty {@code Bootstrap} and/or a {@code ScheduledExecutorService} has not been provided they
         * will be created.
         *
         * @return a new Riaknode
         */
        public RiakNode build()
        {
<span class="fc" id="L1572">            return new RiakNode(this);</span>
        }

        /**
         * Build a set of RiakNodes.
         * The provided builder will be used to construct a set of RiakNodes
         * using the supplied addresses.
         *
         * @param builder         a configured builder, used for common properties among the nodes
         * @param remoteAddresses a list of IP addresses or FQDN.
         *                        Since 2.0.3 each of list item is treated as a comma separated list
         *                        of FQDN or IP addresses with the optional remote port delimited by ':'.
         * @return a list of constructed RiakNodes
         */
        public static List&lt;RiakNode&gt; buildNodes(Builder builder, List&lt;String&gt; remoteAddresses)
        {
<span class="fc" id="L1588">            final Set&lt;HostAndPort&gt; hps = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L1589" title="All 2 branches covered.">            for (String remoteAddress: remoteAddresses)</span>
            {
<span class="fc" id="L1591">                hps.addAll( HostAndPort.hostsFromString(remoteAddress, builder.port) );</span>
<span class="fc" id="L1592">            }</span>

<span class="fc" id="L1594">            return buildNodes(hps, builder);</span>
        }

        /**
         * Build a set of RiakNodes.
         * The provided builder will be used to construct a set of RiakNodes
         * using the supplied hosts.
         *
         * @param remoteHosts     a list of hosts w/wo ports.
         * @param builder         a configured builder, used for common properties among the nodes
         *
         * @return a list of constructed RiakNodes
         * @since 2.0.6
         */
        public static List&lt;RiakNode&gt; buildNodes(Collection&lt;HostAndPort&gt; remoteHosts, Builder builder)
        {
            final Set&lt;HostAndPort&gt; hps;
<span class="pc bpc" id="L1611" title="1 of 2 branches missed.">            if (!(remoteHosts instanceof Set))</span>
            {
<span class="nc" id="L1613">                hps = new HashSet&lt;&gt;(remoteHosts);</span>
            }
            else
            {
<span class="fc" id="L1617">                hps = (Set&lt;HostAndPort&gt;) remoteHosts;</span>
            }

<span class="fc" id="L1620">            final List&lt;RiakNode&gt; nodes = new ArrayList&lt;&gt;(hps.size());</span>
<span class="fc bfc" id="L1621" title="All 2 branches covered.">            for (HostAndPort hp : hps)</span>
            {
<span class="fc" id="L1623">                builder.withRemoteAddress(hp);</span>
<span class="fc" id="L1624">                nodes.add(builder.build());</span>
<span class="fc" id="L1625">            }</span>
<span class="fc" id="L1626">            return nodes;</span>
        }

        /**
         * Build a set of RiakNodes.
         * The provided builder will be used to construct a set of RiakNodes using the supplied addresses.
         *
         * @since 2.0.3
         * @see #buildNodes(RiakNode.Builder, List)
         */
        public static List&lt;RiakNode&gt; buildNodes(Builder builder, String... remoteAddresses)
                throws UnknownHostException
        {
<span class="fc" id="L1639">            return buildNodes(builder, Arrays.asList(remoteAddresses));</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>