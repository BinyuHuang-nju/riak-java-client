<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CreateTableOperation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Riak Client for Java</a> &gt; <a href="index.source.html" class="el_package">com.basho.riak.client.core.operations.ts</a> &gt; <span class="el_source">CreateTableOperation.java</span></div><h1>CreateTableOperation.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2013-2016 Basho Technologies Inc
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.basho.riak.client.core.operations.ts;

import com.basho.riak.client.core.operations.PBFutureOperation;
import com.basho.riak.client.core.query.timeseries.ColumnDescription;
import com.basho.riak.client.core.query.timeseries.FullColumnDescription;
import com.basho.riak.client.core.query.timeseries.Quantum;
import com.basho.riak.client.core.query.timeseries.TableDefinition;
import com.basho.riak.protobuf.RiakMessageCodes;
import com.basho.riak.protobuf.RiakTsPB;
import com.google.protobuf.ByteString;

import java.util.Collection;
import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * An operation to create a Riak Time Series table according to the provided definition.
 *
 * @author Sergey Galkin &lt;srggal at gmail dot com&gt;
 * @since 2.0.6
 */
public class CreateTableOperation extends PBFutureOperation&lt;Void, RiakTsPB.TsQueryResp, String&gt;
{
    private final String queryText;

    private CreateTableOperation(AbstractBuilder builder)
    {
<span class="fc" id="L43">        super(RiakMessageCodes.MSG_TsQueryReq,</span>
                RiakMessageCodes.MSG_TsQueryResp,
<span class="fc" id="L45">                builder.reqBuilder,</span>
                RiakTsPB.TsQueryResp.PARSER);

<span class="fc" id="L48">        this.queryText = builder.queryText;</span>
<span class="fc" id="L49">    }</span>

    @Override
    protected Void convert(List&lt;RiakTsPB.TsQueryResp&gt; rawResponse)
    {
<span class="nc" id="L54">        return null;</span>
    }

    @Override
    public String getQueryInfo()
    {
<span class="nc" id="L60">        return this.queryText;</span>
    }

    public static abstract class AbstractBuilder&lt;R, THIS extends AbstractBuilder&gt;
    {
        private RiakTsPB.TsQueryReq.Builder reqBuilder;
        private String queryText;
        private int quantum;
        private char quantumUnit;
        private final TableDefinition tableDefinition;

        public AbstractBuilder(TableDefinition tableDefinition)
<span class="fc" id="L72">        {</span>
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">            if (tableDefinition == null)</span>
            {
<span class="nc" id="L75">                throw new IllegalArgumentException(&quot;TableDefinition cannot be null.&quot;);</span>
            }

<span class="fc" id="L78">            final String tableName = tableDefinition.getTableName();</span>
<span class="pc bpc" id="L79" title="2 of 4 branches missed.">            if (tableName == null || tableName.length() == 0)</span>
            {
<span class="nc" id="L81">                throw new IllegalArgumentException(&quot;Table Name cannot be null or empty&quot;);</span>
            }

<span class="fc" id="L84">            this.tableDefinition = tableDefinition;</span>
<span class="fc" id="L85">            findQuantumInfoInColumnDescriptions();</span>
<span class="fc" id="L86">        }</span>

        public abstract R build();

        public CreateTableOperation buildOperation()
        {
<span class="fc" id="L92">            final String keys = generateKeys(tableDefinition, quantum, quantumUnit).toString();</span>

<span class="fc" id="L94">            queryText = String.format(&quot;CREATE TABLE %s (%s,\n\n PRIMARY KEY (%s))&quot;,</span>
<span class="fc" id="L95">                    tableDefinition.getTableName(), generateColumns(tableDefinition),</span>
                    keys);

<span class="fc" id="L98">            reqBuilder = RiakTsPB.TsQueryReq.newBuilder()</span>
<span class="fc" id="L99">                    .setQuery(RiakTsPB.TsInterpolation.newBuilder().setBase(</span>
<span class="fc" id="L100">                            ByteString.copyFromUtf8(queryText)</span>
                    ));

<span class="fc" id="L103">            return new CreateTableOperation(this);</span>
        }

        /**
         * Sets the quantum information for the partition key.
         * If this method is used, it will override any quantum information included in
         * the original TableDefinition passed into the Builder constructor.
         * @param quantum The quantum interval
         * @param tu The quantum time unit
         * @return a reference to this object.
         */
        @SuppressWarnings(&quot;unchecked&quot;)
        public THIS withQuantum(int quantum, TimeUnit tu)
        {
<span class="fc" id="L117">            this.quantumUnit = Quantum.getTimeUnitChar(tu);</span>
<span class="fc" id="L118">            this.quantum = quantum;</span>
<span class="fc" id="L119">            return (THIS)this;</span>
        }

        private void findQuantumInfoInColumnDescriptions()
        {
<span class="fc bfc" id="L124" title="All 2 branches covered.">            for (FullColumnDescription fullColumnDescription : this.tableDefinition.getPartitionKeyColumnDescriptions())</span>
            {
<span class="fc bfc" id="L126" title="All 2 branches covered.">                if (!fullColumnDescription.hasQuantum())</span>
                {
<span class="fc" id="L128">                    continue;</span>
                }

<span class="fc" id="L131">                final Quantum quantum = fullColumnDescription.getQuantum();</span>
<span class="fc" id="L132">                this.quantum = quantum.getInterval();</span>
<span class="fc" id="L133">                this.quantumUnit = quantum.getUnitAsChar();</span>
<span class="fc" id="L134">            }</span>
<span class="fc" id="L135">        }</span>

        private static StringBuilder generateColumns(TableDefinition tableDefinition)
        {
<span class="fc" id="L139">            final StringBuilder sb = new StringBuilder();</span>

<span class="fc bfc" id="L141" title="All 2 branches covered.">            for (FullColumnDescription fd: tableDefinition.getFullColumnDescriptions())</span>
            {
<span class="fc bfc" id="L143" title="All 2 branches covered.">                if (sb.length() &gt; 0)</span>
                {
<span class="fc" id="L145">                    sb.append(&quot;,\n &quot;);</span>
                }

<span class="fc" id="L148">                sb.append(fd.getName())</span>
<span class="fc" id="L149">                        .append(' ')</span>
<span class="fc" id="L150">                        .append(fd.getType().name());</span>

<span class="fc bfc" id="L152" title="All 2 branches covered.">                if (!fd.isNullable())</span>
                {
<span class="fc" id="L154">                    sb.append(&quot; not null&quot;);</span>
                }
<span class="fc" id="L156">            }</span>

<span class="fc" id="L158">            return sb;</span>
        }

        private static StringBuilder generateKeys(TableDefinition tableDefinition, int quantum, char quantumUnit)
        {
<span class="fc" id="L163">            final Collection&lt;FullColumnDescription&gt; pks = tableDefinition.getPartitionKeyColumnDescriptions();</span>
<span class="pc bpc" id="L164" title="2 of 4 branches missed.">            if (pks == null || pks.isEmpty())</span>
            {
<span class="nc" id="L166">                throw new IllegalArgumentException(&quot;No defined primary keys, at least one primary key should be defined.&quot;);</span>
            }

<span class="fc" id="L169">            boolean quantumGenerated = false;</span>
<span class="fc" id="L170">            final StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">            for (FullColumnDescription k: pks)</span>
            {
<span class="fc bfc" id="L173" title="All 2 branches covered.">                if (sb.length() &gt; 0)</span>
                {
<span class="fc" id="L175">                    sb.append(&quot;, &quot;);</span>
                }
                else
                {
<span class="fc" id="L179">                    sb.append('(');</span>
                }

<span class="pc bpc" id="L182" title="1 of 4 branches missed.">                if (!quantumGenerated &amp;&amp; ColumnDescription.ColumnType.TIMESTAMP.equals(k.getType()))</span>
                {
                    // handle quantum
<span class="fc" id="L185">                    sb.append(&quot;quantum(&quot;)</span>
<span class="fc" id="L186">                        .append(k.getName())</span>
<span class="fc" id="L187">                        .append(',')</span>
<span class="fc" id="L188">                        .append(quantum)</span>
<span class="fc" id="L189">                        .append(',')</span>
<span class="fc" id="L190">                        .append(quantumUnit)</span>
<span class="fc" id="L191">                        .append(')');</span>

<span class="fc" id="L193">                    quantumGenerated = true;</span>
                }
                else
                {
<span class="fc" id="L197">                    sb.append(k.getName());</span>
                }
<span class="fc" id="L199">            }</span>
<span class="fc" id="L200">            sb.append(')');</span>

<span class="fc bfc" id="L202" title="All 2 branches covered.">            for (FullColumnDescription lk: tableDefinition.getLocalKeyColumnDescriptions())</span>
            {
<span class="fc" id="L204">                sb.append(&quot;, &quot;)</span>
<span class="fc" id="L205">                        .append(lk.getName());</span>

<span class="pc bpc" id="L207" title="1 of 2 branches missed.">                if (lk.hasKeyOrder())</span>
                {
<span class="nc" id="L209">                    sb.append(&quot; &quot;);</span>
<span class="nc" id="L210">                    sb.append(lk.getKeyOrder().toString());</span>
                }
<span class="fc" id="L212">            }</span>

<span class="fc" id="L214">            return sb;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>