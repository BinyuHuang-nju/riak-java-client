<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TTBConverters.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Riak Client for Java</a> &gt; <a href="index.source.html" class="el_package">com.basho.riak.client.core.operations.ts</a> &gt; <span class="el_source">TTBConverters.java</span></div><h1>TTBConverters.java</h1><pre class="source lang-java linenums">package com.basho.riak.client.core.operations.ts;

import com.basho.riak.client.core.codec.InvalidTermToBinaryException;
import com.basho.riak.client.core.codec.TermToBinaryCodec;
import com.basho.riak.client.core.operations.TTBFutureOperation;
import com.basho.riak.client.core.query.timeseries.Cell;
import com.basho.riak.client.core.query.timeseries.QueryResult;
import com.ericsson.otp.erlang.OtpErlangDecodeException;
import com.ericsson.otp.erlang.OtpOutputStream;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.LinkedList;

<span class="nc" id="L15">class TTBConverters</span>
{
<span class="nc" id="L17">    private static Logger logger = LoggerFactory.getLogger(TTBConverters.class);</span>

    private static abstract class BuilderTTBEncoder&lt;T&gt; implements TTBFutureOperation.TTBEncoder
    {
        protected final T builder;

        BuilderTTBEncoder(T builder)
<span class="fc" id="L24">        {</span>
<span class="fc" id="L25">            this.builder = builder;</span>
<span class="fc" id="L26">        }</span>

        abstract OtpOutputStream buildMessage();

        @Override
        public byte[] build()
        {
<span class="nc" id="L33">            return buildMessage().toByteArray();</span>
        }
    }

    static class StoreEncoder extends BuilderTTBEncoder&lt;StoreOperation.Builder&gt;
    {
        StoreEncoder(StoreOperation.Builder builder)
        {
<span class="nc" id="L41">            super(builder);</span>
<span class="nc" id="L42">        }</span>

        @Override
        OtpOutputStream buildMessage()
        {
<span class="nc" id="L47">            return TermToBinaryCodec.encodeTsPutRequest(builder.getTableName(), builder.getColumns(), builder.getRows());</span>
        }
    }

    static class FetchEncoder extends BuilderTTBEncoder&lt;FetchOperation.Builder&gt;
    {
        FetchEncoder(FetchOperation.Builder builder)
        {
<span class="fc" id="L55">            super(builder);</span>
<span class="fc" id="L56">        }</span>

        @Override
        OtpOutputStream buildMessage()
        {
            // TODO: Remove this later
<span class="nc" id="L62">            LinkedList&lt;Cell&gt; list = new LinkedList&lt;&gt;();</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">            for (Cell c : builder.getKeyValues())</span>
            {
<span class="nc" id="L65">                list.add(c);</span>
<span class="nc" id="L66">            }</span>
<span class="nc" id="L67">            return TermToBinaryCodec.encodeTsGetRequest(builder.getTableName(), list, builder.getTimeout());</span>
        }
    }

    static class QueryEncoder extends BuilderTTBEncoder&lt;QueryOperation.Builder&gt;
    {
        QueryEncoder(QueryOperation.Builder builder)
        {
<span class="nc" id="L75">            super(builder);</span>
<span class="nc" id="L76">        }</span>

        @Override
        OtpOutputStream buildMessage()
        {
<span class="nc" id="L81">            return TermToBinaryCodec.encodeTsQueryRequest(builder.getQueryText(), builder.getCoverageContext());</span>
        }
    }

<span class="nc" id="L85">    static class VoidDecoder implements TTBFutureOperation.TTBParser&lt;Void&gt;</span>
    {
        @Override
        public Void parseFrom(byte[] data)
        {
<span class="nc" id="L90">            return null;</span>
        }
    }

<span class="fc" id="L94">    static class QueryResultDecoder implements TTBFutureOperation.TTBParser&lt;QueryResult&gt;</span>
    {
        @Override
        public QueryResult parseFrom(byte[] data)
        {
            QueryResult rv;

            try
            {
<span class="nc" id="L103">                rv = TermToBinaryCodec.decodeTsResultResponse(data);</span>
            }
<span class="nc" id="L105">            catch (OtpErlangDecodeException | InvalidTermToBinaryException ex)</span>
            {
<span class="nc" id="L107">                final String errorMsg = &quot;Error decoding Riak TTB response&quot;;</span>
<span class="nc" id="L108">                logger.error(errorMsg, ex);</span>
<span class="nc" id="L109">                throw new IllegalArgumentException(errorMsg, ex);</span>
<span class="nc" id="L110">            }</span>

<span class="nc" id="L112">            return rv;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>