<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RiakIndexes.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Riak Client for Java</a> &gt; <a href="index.source.html" class="el_package">com.basho.riak.client.core.query.indexes</a> &gt; <span class="el_source">RiakIndexes.java</span></div><h1>RiakIndexes.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2013 Basho Technologies Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.basho.riak.client.core.query.indexes;

import com.basho.riak.client.core.query.RiakObject;

import java.util.Iterator;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Container used to instantiate and Manage {@code RiakIndex} objects to be used with a {@code RiakObject}.
 * &lt;p&gt;
 * This container manages and allows for an arbitrary number and types of {@link RiakIndex}s to
 * be used with a {@link RiakObject}.
 * &lt;/p&gt;
 * &lt;h4&gt;Working with RiakIndexes&lt;/h4&gt;
 * &lt;p&gt;Data in Riak, including secondary indexes, is stored as raw bytes. The conversion
 * to and from bytes is handled by the concrete {@code RiakIndex} implementations
 * and all indexes are managed by this container. &lt;/p&gt;
 * &lt;p&gt;
 * Each concrete {@code RiakIndex} includes a hybrid builder class named {@code Name}.
 * The methods of this class take an instance of that builder as an
 * argument to allow for proper type inference and construction of {@code RiakIndex}
 * objects to expose.
 * &lt;/p&gt;
 * &lt;p&gt;{@code getIndex()} will either return a reference to
 * the existing {@code RiakIndex} or atomically add and return a new one. The
 * returned reference is of the type provided by the {@code Name} and is the
 * mutable index; changes are made directly to it.
 * &lt;/p&gt;
 * &lt;blockquote&gt;&lt;pre&gt;
 * LongIntIndex myIndex = riakIndexes.getIndex(LongIntIndex.named(&quot;number_on_hand&quot;));
 * myIndex.removeAll();
 * myIndex.add(6L);
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * &lt;p&gt;Calls can be chained, allowing for easy addition or removal of values from
 * an index.
 * &lt;/p&gt;
 * &lt;blockquote&gt;&lt;pre&gt;
 * riakIndexes.getIndex(StringBinIndex.named(&quot;colors&quot;)).remove(&quot;blue&quot;).add(&quot;red&quot;);
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * &lt;h6&gt;Special note when using RawIndex&lt;/h6&gt;
 * A {@code RiakIndex} is uniquely identified by its textual name and {@code IndexType}
 * regardless of the concrete {@code RiakIndex} implementation being used to view
 * or update it. This container enforces this uniqueness by being the source of
 * all {@code RiakIndex} instances and managing them in a thread-safe way with
 * atomic operations.
 * &lt;p&gt;
 * What this means is that any {@code RiakIndex} having the same name and {@code Indextype}
 * will refer to the same index. This is only important to note if you are mixing
 * access to the indexes using {@link RawIndex}. The test case copied below demonstrates
 * the relation.&lt;/p&gt;
 * &lt;blockquote&gt;&lt;pre&gt;
 * public void wrapping()
 * {
 *     // creates or fetches the BIN (_bin) index named &quot;foo&quot;, adds a value to it
 *     RawIndex index = indexes.getIndex(RawIndex.named(&quot;foo&quot;, IndexType.BIN));
 *     BinaryValue baw = BinaryValue.unsafeCreate(&quot;value&quot;.getBytes());
 *     index.add(baw);
 *
 *     // fetches the previously created index as a StringBinIndex
 *     StringBinIndex wrapper = indexes.getIndex(StringBinIndex.named(&quot;foo&quot;));
 *
 *     // The references are to different objects
 *     assertNotSame(index, wrapper);
 *     // The two objects are equal ( index.equals(wrapper) == true )
 *     assertEquals(index, wrapper);
 *     // The value exists
 *     assertTrue(wrapper.hasValue(&quot;value&quot;));
 *
 *     // Removing the value via the StringBinIndex is reflected in the RawIndex
 *     wrapper.remove(&quot;value&quot;);
 *     assertFalse(index.hasValue(baw));
 * }
 * &lt;/pre&gt;&lt;/blockquote&gt;
 * &lt;br/&gt;&lt;b&gt;Thread Safety:&lt;/b&gt;&lt;br/&gt; This is a thread safe container.
 * @author Brian Roach &lt;roach at basho dot com&gt;
 * @since 2.0
 * @see RiakObject#getIndexes()
 */
public class RiakIndexes implements Iterable&lt;RiakIndex&lt;?&gt;&gt;
{
<span class="fc" id="L97">    private final ConcurrentHashMap&lt;String, RiakIndex&lt;?&gt;&gt; indexes = new ConcurrentHashMap&lt;&gt;();</span>

    /**
     * Instantiates a new RiakIndexes object containing no RiakIndex objects
     */
    public RiakIndexes()
<span class="fc" id="L103">    {</span>
<span class="fc" id="L104">    }</span>

    /**
     * Return the number of indexes present
     * @return the number of indexes
     */
    public int size()
    {
<span class="fc" id="L112">        return indexes.size();</span>
    }

    /**
     * Returns whether any {@code RiakIndex} objects are present
     * @return {@code true} if there are indexes, {@code false} otherwise
     */
    public boolean isEmpty()
    {
<span class="fc" id="L121">        return indexes.isEmpty();</span>
    }

    /**
     * Returns whether a specific RiakIndex is present
     * @param name the {@link RiakIndex.Name} representing the index to check for
     * @return {@code true} if the index is present, {@code false} otherwise
     */
    public &lt;T extends RiakIndex&lt;?&gt;&gt; boolean hasIndex(RiakIndex.Name&lt;T&gt; name)
    {
<span class="fc" id="L131">        return indexes.containsKey(name.getFullname());</span>
    }

    /**
     * Get the named RiakIndex
     * &lt;p&gt;
     * If the named index does not exist it is created and added to the container
     * before being returned.
     * &lt;/p&gt;
     * &lt;p&gt;Scala Users: to chain RiakIndex method calls off of this method
     * please include explicit type parameters for the getIndex() call.
     * e.g.
     * &lt;/p&gt;
     * &lt;blockquote&gt;&lt;pre&gt;
     * riakIndexes.getIndex[StringBinIndex,StringBinIndex.Name](StringBinIndex.named(&quot;myindex&quot;)).add(&quot;myvalue&quot;)
     * &lt;/pre&gt;&lt;/blockquote&gt;
     * @param name The {@link RiakIndex.Name} of the index to retrieve.
     * @return The requested index typed accordingly.
     */
    public &lt;V extends RiakIndex&lt;?&gt;, T extends RiakIndex.Name&lt;V&gt;&gt; V getIndex(T name)
    {
<span class="fc" id="L152">        RiakIndex&lt;?&gt; existing = indexes.get(name.getFullname());</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">        if (existing != null)</span>
        {
<span class="fc" id="L155">            return name.wrap(existing).createIndex();</span>
        }
        else
        {
<span class="fc" id="L159">            V newIndex = name.createIndex();</span>
<span class="fc" id="L160">            existing = indexes.putIfAbsent(newIndex.getFullname(), newIndex);</span>
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">            if (existing != null)</span>
            {
<span class="nc" id="L163">                return getIndex(name);</span>
            }
            else
            {
<span class="fc" id="L167">                return newIndex;</span>
            }
        }
    }

    /**
     * Remove the named RiakIndex
     * @param name the {@code RiakIndex.Name} representing the index to remove
     * @return the removed {@code RiakIndex} (typed accordingly) if the index was present,
     *  {@code null} otherwise
     */
    public &lt;V,T extends RiakIndex&lt;V&gt;&gt; T removeIndex(RiakIndex.Name&lt;T&gt; name)
    {
<span class="fc" id="L180">        RiakIndex&lt;?&gt; removed = indexes.remove(name.getFullname());</span>
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">        if (removed != null)</span>
        {
<span class="fc" id="L183">            T index = name.wrap(removed).createIndex();</span>
<span class="fc" id="L184">            return index;</span>
        }
        else
        {
<span class="nc" id="L188">            return null;</span>
        }
    }

    /**
     * Remove all indexes.
     */
    public void removeAllIndexes()
    {
<span class="fc" id="L197">        indexes.clear();</span>
<span class="fc" id="L198">    }</span>

        @Override
        public Iterator&lt;RiakIndex&lt;?&gt;&gt; iterator()
        {
<span class="fc" id="L203">                return indexes.values().iterator();</span>
        }

    @Override
    public boolean equals(Object o)
    {
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">        if (this == o)</span>
        {
<span class="nc" id="L211">            return true;</span>
        }
<span class="pc bpc" id="L213" title="2 of 4 branches missed.">        if (o == null || getClass() != o.getClass())</span>
        {
<span class="nc" id="L215">            return false;</span>
        }

<span class="fc" id="L218">        RiakIndexes that = (RiakIndexes) o;</span>
<span class="fc" id="L219">        return indexes.equals(that.indexes);</span>
    }

    @Override
    public int hashCode()
    {
<span class="nc" id="L225">        return indexes.hashCode();</span>
    }

    @Override
    public String toString()
    {
<span class="nc" id="L231">        return &quot;RiakIndexes{&quot; +</span>
                &quot;indexes: &quot; + indexes +
                '}';
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>